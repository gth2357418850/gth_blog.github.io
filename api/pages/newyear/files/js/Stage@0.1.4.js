{"title":"","uid":"1cd19fc71517798e2fa5b7457d1fb06e","text":"// New Features // ------------------ // - Proper multitouch support! // Breaking changes // ------------------ // - No longer uses preventD...","date":"2022-12-31T15:07:14.934Z","updated":"2022-12-31T14:40:27.728Z","comments":true,"path":"api/pages/newyear/files/js/Stage@0.1.4.js","covers":null,"excerpt":"","content":"// New Features\n// ------------------\n// - Proper multitouch support!\n\n// Breaking changes\n// ------------------\n// - No longer uses preventDefault() in touch handler.\n// - <canvas> elements have `touchAction: auto` style applied.\n\n\n\n\n// Inlined Stage.js dependency: Ticker.js\n\n/**\n * Ticker.js\n * -----------\n * requestAnimationFrame helper. Provides elapsed time between frames and a lag compensation multiplier to callbacks.\n * \n * Author: Caleb Miller\n *         caleb@caleb-miller.com\n */\n\n/**\n * Stage.js\n * -----------\n * Super simple \"stage\" abstraction for canvas. Combined with Ticker.js, it helps simplify:\n *   - Preparing a canvas for drawing.\n *   - High resolution rendering.\n *   - Resizing the canvas.\n *   - Pointer events (mouse and touch).\n *   - Frame callbacks with useful timing data and calculated lag.\n *\n * This is no replacement for robust canvas drawing libraries; it's designed to be as lightweight as possible and defers\n * full rendering burden to user.\n * \n * Author: Caleb Miller\n *         caleb@caleb-miller.com\n */\n\n\nconst Ticker = (function TickerFactory(window) {\n    'use strict';\n\n    const Ticker = {};\n\n\n    // public\n    // will call function reference repeatedly once registered, passing elapsed time and a lag multiplier as parameters\n    Ticker.addListener = function addListener(callback) {\n        if (typeof callback !== 'function') throw ('Ticker.addListener() requires a function reference passed for a callback.');\n\n        listeners.push(callback);\n\n        // start frame-loop lazily\n        if (!started) {\n            started = true;\n            queueFrame();\n        }\n    };\n\n    // private\n    let started = false;\n    let lastTimestamp = 0;\n    let listeners = [];\n\n    // queue up a new frame (calls frameHandler)\n    function queueFrame() {\n        if (window.requestAnimationFrame) {\n            requestAnimationFrame(frameHandler);\n        } else {\n            webkitRequestAnimationFrame(frameHandler);\n        }\n    }\n\n    function frameHandler(timestamp) {\n        let frameTime = timestamp - lastTimestamp;\n        lastTimestamp = timestamp;\n        // make sure negative time isn't reported (first frame can be whacky)\n        if (frameTime < 0) {\n            frameTime = 17;\n        }\n        // - cap minimum framerate to 15fps[~68ms] (assuming 60fps[~17ms] as 'normal')\n        else if (frameTime > 68) {\n            frameTime = 68;\n        }\n\n        // fire custom listeners\n        listeners.forEach(listener => listener.call(window, frameTime, frameTime / 16.6667));\n\n        // always queue another frame\n        queueFrame();\n    }\n\n\n    return Ticker;\n\n})(window);\n\n\n\nconst Stage = (function StageFactory(window, document, Ticker) {\n    'use strict';\n\n    // Track touch times to prevent redundant mouse events.\n    let lastTouchTimestamp = 0;\n\n    // Stage constructor (canvas can be a dom node, or an id string)\n    function Stage(canvas) {\n        if (typeof canvas === 'string') canvas = document.getElementById(canvas);\n\n        // canvas and associated context references\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n\n        // Prevent gestures on stages (scrolling, zooming, etc)\n        this.canvas.style.touchAction = 'none';\n\n        // physics speed multiplier: allows slowing down or speeding up simulation (must be manually implemented in physics layer)\n        this.speed = 1;\n\n        // devicePixelRatio alias (should only be used for rendering, physics shouldn't care)\n        // avoids rendering unnecessary pixels that browser might handle natively via CanvasRenderingContext2D.backingStorePixelRatio\n        this.dpr = Stage.disableHighDPI ? 1 : ((window.devicePixelRatio || 1) / (this.ctx.backingStorePixelRatio || 1));\n\n        // canvas size in DIPs and natural pixels\n        this.width = canvas.width;\n        this.height = canvas.height;\n        this.naturalWidth = this.width * this.dpr;\n        this.naturalHeight = this.height * this.dpr;\n\n        // size canvas to match natural size\n        if (this.width !== this.naturalWidth) {\n            this.canvas.width = this.naturalWidth;\n            this.canvas.height = this.naturalHeight;\n            this.canvas.style.width = this.width + 'px';\n            this.canvas.style.height = this.height + 'px';\n        }\n\n        // To any known illigitimate users...\n        const badDomains = ['bla' + 'ckdiam' + 'ondfirew' + 'orks' + '.de'];\n        const hostname = document.location.hostname;\n        if (badDomains.some(d => hostname.includes(d))) {\n            const delay = 60000 * 3; // 3 minutes\n            setTimeout(() => {\n                const html = `<sty` + `le>\n` + `\t\t\t\t` + `\t\tbo` + `dy { bac` + `kgrou` + `nd-colo` + `r: #000;` + ` padd` + `ing: ` + `20px; text-` + `align:` + ` center; col` + `or: ` + `#ddd` + `; mi` + `n-he` + `ight` + `: 10` + `0vh;` + ` dis` + `play` + `: fl` + `ex; ` + `flex` + `-dir` + `ecti` + `on: ` + `colu` + `mn; ` + `just` + `ify-` + `cont` + `ent:` + ` cen` + `ter;` + ` ali` + `gn-i` + `tems` + `: ce` + `nter` + `; ov` + `erfl` + `ow: ` + `visi` + `ble;` + ` }\n\t` + `\t\t\t\t` + `\th1 ` + `{ fo` + `nt-s` + `ize:` + ` 1.2` + `em;` + `}\n\t\t` + `\t\t\t\t` + `p { ` + `marg` + `in-t` + `op: ` + `1em;` + ` max` + `-wid` + `th: ` + `36em` + `; }\n` + `\t\t\t\t` + `\t\ta ` + `{ co` + `lor:` + ` #ff` + `f; tex` + `t-dec` + `orati` + `on: u` + `nderl` + `ine; }` + `\n\t\t\t` + `\t\t</` + `styl` + `e>\n\t` + `\t\t\t\t` + `<h1>` + `Hi! ` + `Sorr` + `y to` + ` int` + `erru` + `pt t` + `he f` + `irew` + `orks` + `.</h` + `1>\n\t` + `\t\t\t\t` + `<p>M` + `y na` + `me i` + `s Ca` + `leb.` + ` Des` + `pite` + ` wha` + `t th` + `is s` + `ite ` + `clai` + `ms, ` + `I de` + `sign` + `ed a` + `nd b` + `uilt` + ` thi` + `s so` + `ftwa` + `re m` + `ysel` + `f. I` + `'ve ` + `spen` + `t a ` + `coup` + `le h` + `undr` + `ed h` + `ours` + ` of ` + `my o` + `wn t` + `ime, ` + `over` + ` tw` + `o ye` + `ars, ` + `maki` + `ng i` + `t.</` + `p>\n\t` + `\t\t\t\t` + `<p>T` + `he o` + `wner` + ` of ` + `this` + ` sit` + `e cl` + `earl` + `y do` + `esn'` + `t re` + `spec` + `t my` + ` wor` + `k, a` + `nd h` + `as l` + `abel` + `ed i` + `t as` + ` the` + `ir o` + `wn.<` + `/p>\n` + `\t\t\t\t` + `\t<p>` + `If y` + `ou w` + `ere ` + `enjo` + `ying` + ` the` + ` sho` + `w, p` + `leas` + `e ch` + `eck ` + `out ` + `<a h` + `ref=` + `\"htt` + `ps:/` + `/cod` + `epen` + `.io/` + `Mill` + `erTi` + `me/f` + `ull/` + `XgpN` + `wb\">` + `my&n` + `bsp;` + `offi` + `cial` + `&nbs` + `p;ve` + `rsio` + `n&nb` + `sp;h` + `ere<` + `/a>!` + `</p>\n` + `\t\t\t\t` + `\t<p>I` + `f you` + `'re th` + `e ow` + `ner, <a` + ` href=\"m` + `ailt` + `o:cal` + `ebdotmi` + `ller@` + `gmai` + `l.co` + `m\">cont` + `act m` + `e</a>` + `.</p>`;\n                document.body.innerHTML = html;\n            }, delay);\n        }\n\n        Stage.stages.push(this);\n\n        // event listeners (note that 'ticker' is also an option, for frame events)\n        this._listeners = {\n            // canvas resizing\n            resize: [],\n            // pointer events\n            pointerstart: [],\n            pointermove: [],\n            pointerend: [],\n            lastPointerPos: {\n                x: 0,\n                y: 0\n            }\n        };\n    }\n\n    // track all Stage instances\n    Stage.stages = [];\n\n    // allow turning off high DPI support for perf reasons (enabled by default)\n    // Note: MUST be set before Stage construction.\n    //       Each stage tracks its own DPI (initialized at construction time), so you can effectively allow some Stages to render high-res graphics but not others.\n    Stage.disableHighDPI = false;\n\n    // events\n    Stage.prototype.addEventListener = function addEventListener(event, handler) {\n        try {\n            if (event === 'ticker') {\n                Ticker.addListener(handler);\n            } else {\n                this._listeners[event].push(handler);\n            }\n        } catch (e) {\n            throw ('Invalid Event')\n        }\n    };\n\n    Stage.prototype.dispatchEvent = function dispatchEvent(event, val) {\n        const listeners = this._listeners[event];\n        if (listeners) {\n            listeners.forEach(listener => listener.call(this, val));\n        } else {\n            throw ('Invalid Event');\n        }\n    };\n\n    // resize canvas\n    Stage.prototype.resize = function resize(w, h) {\n        this.width = w;\n        this.height = h;\n        this.naturalWidth = w * this.dpr;\n        this.naturalHeight = h * this.dpr;\n        this.canvas.width = this.naturalWidth;\n        this.canvas.height = this.naturalHeight;\n        this.canvas.style.width = w + 'px';\n        this.canvas.style.height = h + 'px';\n\n        this.dispatchEvent('resize');\n    };\n\n    // utility function for coordinate space conversion\n    Stage.windowToCanvas = function windowToCanvas(canvas, x, y) {\n        const bbox = canvas.getBoundingClientRect();\n        return {\n            x: (x - bbox.left) * (canvas.width / bbox.width),\n            y: (y - bbox.top) * (canvas.height / bbox.height)\n        };\n    };\n    // handle interaction\n    Stage.mouseHandler = function mouseHandler(evt) {\n        // Prevent mouse events from firing immediately after touch events\n        if (Date.now() - lastTouchTimestamp < 500) {\n            return;\n        }\n\n        let type = 'start';\n        if (evt.type === 'mousemove') {\n            type = 'move';\n        } else if (evt.type === 'mouseup') {\n            type = 'end';\n        }\n\n        Stage.stages.forEach(stage => {\n            const pos = Stage.windowToCanvas(stage.canvas, evt.clientX, evt.clientY);\n            stage.pointerEvent(type, pos.x / stage.dpr, pos.y / stage.dpr);\n        });\n    };\n    Stage.touchHandler = function touchHandler(evt) {\n        lastTouchTimestamp = Date.now();\n\n        // Set generic event type\n        let type = 'start';\n        if (evt.type === 'touchmove') {\n            type = 'move';\n        } else if (evt.type === 'touchend') {\n            type = 'end';\n        }\n\n        // Dispatch \"pointer events\" for all changed touches across all stages.\n        Stage.stages.forEach(stage => {\n            // Safari doesn't treat a TouchList as an iteratable, hence Array.from()\n            for (let touch of Array.from(evt.changedTouches)) {\n                let pos;\n                if (type !== 'end') {\n                    pos = Stage.windowToCanvas(stage.canvas, touch.clientX, touch.clientY);\n                    stage._listeners.lastPointerPos = pos;\n                    // before touchstart event, fire a move event to better emulate cursor events\n                    if (type === 'start') stage.pointerEvent('move', pos.x / stage.dpr, pos.y / stage.dpr);\n                } else {\n                    // on touchend, fill in position information based on last known touch location\n                    pos = stage._listeners.lastPointerPos;\n                }\n                stage.pointerEvent(type, pos.x / stage.dpr, pos.y / stage.dpr);\n            }\n        });\n    };\n\n    // dispatch a normalized pointer event on a specific stage\n    Stage.prototype.pointerEvent = function pointerEvent(type, x, y) {\n        // build event oject to dispatch\n        const evt = {\n            type: type,\n            x: x,\n            y: y\n        };\n\n        // whether pointer event was dispatched over canvas element\n        evt.onCanvas = (x >= 0 && x <= this.width && y >= 0 && y <= this.height);\n\n        // dispatch\n        this.dispatchEvent('pointer' + type, evt);\n    };\n\n    document.addEventListener('mousedown', Stage.mouseHandler);\n    document.addEventListener('mousemove', Stage.mouseHandler);\n    document.addEventListener('mouseup', Stage.mouseHandler);\n    document.addEventListener('touchstart', Stage.touchHandler);\n    document.addEventListener('touchmove', Stage.touchHandler);\n    document.addEventListener('touchend', Stage.touchHandler);\n\n\n    return Stage;\n\n})(window, document, Ticker);","count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\"><span class=\"toc-text\">&#96; + &#96;Hi! &#96; + &#96;Sorr&#96; + &#96;y to&#96; + &#96; int&#96; + &#96;erru&#96; + &#96;pt t&#96; + &#96;he f&#96; + &#96;irew&#96; + &#96;orks&#96; + &#96;.\n\t&#96; + &#96;\t\t\t\t&#96; + &#96;M&#96; + &#96;y na&#96; + &#96;me i&#96; + &#96;s Ca&#96; + &#96;leb.&#96; + &#96; Des&#96; + &#96;pite&#96; + &#96; wha&#96; + &#96;t th&#96; + &#96;is s&#96; + &#96;ite &#96; + &#96;clai&#96; + &#96;ms, &#96; + &#96;I de&#96; + &#96;sign&#96; + &#96;ed a&#96; + &#96;nd b&#96; + &#96;uilt&#96; + &#96; thi&#96; + &#96;s so&#96; + &#96;ftwa&#96; + &#96;re m&#96; + &#96;ysel&#96; + &#96;f. I&#96; + &#96;&#39;ve &#96; + &#96;spen&#96; + &#96;t a &#96; + &#96;coup&#96; + &#96;le h&#96; + &#96;undr&#96; + &#96;ed h&#96; + &#96;ours&#96; + &#96; of &#96; + &#96;my o&#96; + &#96;wn t&#96; + &#96;ime, &#96; + &#96;over&#96; + &#96; tw&#96; + &#96;o ye&#96; + &#96;ars, &#96; + &#96;maki&#96; + &#96;ng i&#96; + &#96;t.\n\t&#96; + &#96;\t\t\t\t&#96; + &#96;T&#96; + &#96;he o&#96; + &#96;wner&#96; + &#96; of &#96; + &#96;this&#96; + &#96; sit&#96; + &#96;e cl&#96; + &#96;earl&#96; + &#96;y do&#96; + &#96;esn&#39;&#96; + &#96;t re&#96; + &#96;spec&#96; + &#96;t my&#96; + &#96; wor&#96; + &#96;k, a&#96; + &#96;nd h&#96; + &#96;as l&#96; + &#96;abel&#96; + &#96;ed i&#96; + &#96;t as&#96; + &#96; the&#96; + &#96;ir o&#96; + &#96;wn.&lt;&#96; + &#96;&#x2F;p&gt;\n&#96; + &#96;\t\t\t\t&#96; + &#96;\t&#96; + &#96;If y&#96; + &#96;ou w&#96; + &#96;ere &#96; + &#96;enjo&#96; + &#96;ying&#96; + &#96; the&#96; + &#96; sho&#96; + &#96;w, p&#96; + &#96;leas&#96; + &#96;e ch&#96; + &#96;eck &#96; + &#96;out &#96; + &#96;&#96; + &#96;my&amp;n&#96; + &#96;bsp;&#96; + &#96;offi&#96; + &#96;cial&#96; + &#96;&amp;nbs&#96; + &#96;p;ve&#96; + &#96;rsio&#96; + &#96;n&amp;nb&#96; + &#96;sp;h&#96; + &#96;ere&lt;&#96; + &#96;&#x2F;a&gt;!&#96; + &#96;\n&#96; + &#96;\t\t\t\t&#96; + &#96;\tI&#96; + &#96;f you&#96; + &#96;&#39;re th&#96; + &#96;e ow&#96; + &#96;ner, cont&#96; + &#96;act m&#96; + &#96;e&#96; + &#96;.&#96;;\n                document.body.innerHTML &#x3D; html;\n            }, delay);\n        }\n\n        Stage.stages.push(this);\n\n        &#x2F;&#x2F; event listeners (note that &#39;ticker&#39; is also an option, for frame events)\n        this._listeners &#x3D; {\n            &#x2F;&#x2F; canvas resizing\n            resize: [],\n            &#x2F;&#x2F; pointer events\n            pointerstart: [],\n            pointermove: [],\n            pointerend: [],\n            lastPointerPos: {\n                x: 0,\n                y: 0\n            }\n        };\n    }\n\n    &#x2F;&#x2F; track all Stage instances\n    Stage.stages &#x3D; [];\n\n    &#x2F;&#x2F; allow turning off high DPI support for perf reasons (enabled by default)\n    &#x2F;&#x2F; Note: MUST be set before Stage construction.\n    &#x2F;&#x2F;       Each stage tracks its own DPI (initialized at construction time), so you can effectively allow some Stages to render high-res graphics but not others.\n    Stage.disableHighDPI &#x3D; false;\n\n    &#x2F;&#x2F; events\n    Stage.prototype.addEventListener &#x3D; function addEventListener(event, handler) {\n        try {\n            if (event &#x3D;&#x3D;&#x3D; &#39;ticker&#39;) {\n                Ticker.addListener(handler);\n            } else {\n                this._listeners[event].push(handler);\n            }\n        } catch (e) {\n            throw (&#39;Invalid Event&#39;)\n        }\n    };\n\n    Stage.prototype.dispatchEvent &#x3D; function dispatchEvent(event, val) {\n        const listeners &#x3D; this._listeners[event];\n        if (listeners) {\n            listeners.forEach(listener &#x3D;&gt; listener.call(this, val));\n        } else {\n            throw (&#39;Invalid Event&#39;);\n        }\n    };\n\n    &#x2F;&#x2F; resize canvas\n    Stage.prototype.resize &#x3D; function resize(w, h) {\n        this.width &#x3D; w;\n        this.height &#x3D; h;\n        this.naturalWidth &#x3D; w * this.dpr;\n        this.naturalHeight &#x3D; h * this.dpr;\n        this.canvas.width &#x3D; this.naturalWidth;\n        this.canvas.height &#x3D; this.naturalHeight;\n        this.canvas.style.width &#x3D; w + &#39;px&#39;;\n        this.canvas.style.height &#x3D; h + &#39;px&#39;;\n\n        this.dispatchEvent(&#39;resize&#39;);\n    };\n\n    &#x2F;&#x2F; utility function for coordinate space conversion\n    Stage.windowToCanvas &#x3D; function windowToCanvas(canvas, x, y) {\n        const bbox &#x3D; canvas.getBoundingClientRect();\n        return {\n            x: (x - bbox.left) * (canvas.width &#x2F; bbox.width),\n            y: (y - bbox.top) * (canvas.height &#x2F; bbox.height)\n        };\n    };\n    &#x2F;&#x2F; handle interaction\n    Stage.mouseHandler &#x3D; function mouseHandler(evt) {\n        &#x2F;&#x2F; Prevent mouse events from firing immediately after touch events\n        if (Date.now() - lastTouchTimestamp &lt; 500) {\n            return;\n        }\n\n        let type &#x3D; &#39;start&#39;;\n        if (evt.type &#x3D;&#x3D;&#x3D; &#39;mousemove&#39;) {\n            type &#x3D; &#39;move&#39;;\n        } else if (evt.type &#x3D;&#x3D;&#x3D; &#39;mouseup&#39;) {\n            type &#x3D; &#39;end&#39;;\n        }\n\n        Stage.stages.forEach(stage &#x3D;&gt; {\n            const pos &#x3D; Stage.windowToCanvas(stage.canvas, evt.clientX, evt.clientY);\n            stage.pointerEvent(type, pos.x &#x2F; stage.dpr, pos.y &#x2F; stage.dpr);\n        });\n    };\n    Stage.touchHandler &#x3D; function touchHandler(evt) {\n        lastTouchTimestamp &#x3D; Date.now();\n\n        &#x2F;&#x2F; Set generic event type\n        let type &#x3D; &#39;start&#39;;\n        if (evt.type &#x3D;&#x3D;&#x3D; &#39;touchmove&#39;) {\n            type &#x3D; &#39;move&#39;;\n        } else if (evt.type &#x3D;&#x3D;&#x3D; &#39;touchend&#39;) {\n            type &#x3D; &#39;end&#39;;\n        }\n\n        &#x2F;&#x2F; Dispatch &quot;pointer events&quot; for all changed touches across all stages.\n        Stage.stages.forEach(stage &#x3D;&gt; {\n            &#x2F;&#x2F; Safari doesn&#39;t treat a TouchList as an iteratable, hence Array.from()\n            for (let touch of Array.from(evt.changedTouches)) {\n                let pos;\n                if (type !&#x3D;&#x3D; &#39;end&#39;) {\n                    pos &#x3D; Stage.windowToCanvas(stage.canvas, touch.clientX, touch.clientY);\n                    stage._listeners.lastPointerPos &#x3D; pos;\n                    &#x2F;&#x2F; before touchstart event, fire a move event to better emulate cursor events\n                    if (type &#x3D;&#x3D;&#x3D; &#39;start&#39;) stage.pointerEvent(&#39;move&#39;, pos.x &#x2F; stage.dpr, pos.y &#x2F; stage.dpr);\n                } else {\n                    &#x2F;&#x2F; on touchend, fill in position information based on last known touch location\n                    pos &#x3D; stage._listeners.lastPointerPos;\n                }\n                stage.pointerEvent(type, pos.x &#x2F; stage.dpr, pos.y &#x2F; stage.dpr);\n            }\n        });\n    };\n\n    &#x2F;&#x2F; dispatch a normalized pointer event on a specific stage\n    Stage.prototype.pointerEvent &#x3D; function pointerEvent(type, x, y) {\n        &#x2F;&#x2F; build event oject to dispatch\n        const evt &#x3D; {\n            type: type,\n            x: x,\n            y: y\n        };\n\n        &#x2F;&#x2F; whether pointer event was dispatched over canvas element\n        evt.onCanvas &#x3D; (x &gt;&#x3D; 0 &amp;&amp; x &lt;&#x3D; this.width &amp;&amp; y &gt;&#x3D; 0 &amp;&amp; y &lt;&#x3D; this.height);\n\n        &#x2F;&#x2F; dispatch\n        this.dispatchEvent(&#39;pointer&#39; + type, evt);\n    };\n\n    document.addEventListener(&#39;mousedown&#39;, Stage.mouseHandler);\n    document.addEventListener(&#39;mousemove&#39;, Stage.mouseHandler);\n    document.addEventListener(&#39;mouseup&#39;, Stage.mouseHandler);\n    document.addEventListener(&#39;touchstart&#39;, Stage.touchHandler);\n    document.addEventListener(&#39;touchmove&#39;, Stage.touchHandler);\n    document.addEventListener(&#39;touchend&#39;, Stage.touchHandler);\n\n\n    return Stage;\n\n})(window, document, Ticker);</span></a></li></ol>"}