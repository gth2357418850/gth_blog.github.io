{"title":"","uid":"1cd19fc71517798e2fa5b7457d1fb06e","text":"'use strict'; console.clear(); // This is a prime example of what starts out as a simple project // and snowballs way beyond its intended si...","date":"2022-12-31T15:07:14.941Z","updated":"2022-12-31T14:40:27.728Z","comments":true,"path":"api/pages/newyear/files/js/script.js","covers":null,"excerpt":"","content":"'use strict';\nconsole.clear();\n// This is a prime example of what starts out as a simple project\n// and snowballs way beyond its intended size. It's a little clunky\n// reading/working on this single file, but here it is anyways :)\n\nconst IS_MOBILE = window.innerWidth <= 640;\nconst IS_DESKTOP = window.innerWidth > 800;\nconst IS_HEADER = IS_DESKTOP && window.innerHeight < 300;\n// Detect high end devices. This will be a moving target.\nconst IS_HIGH_END_DEVICE = (() => {\n    const hwConcurrency = navigator.hardwareConcurrency;\n    if (!hwConcurrency) {\n        return false;\n    }\n    // Large screens indicate a full size computer, which often have hyper threading these days.\n    // So a quad core desktop machine has 8 cores. We'll place a higher min threshold there.\n    const minCount = window.innerWidth <= 1024 ? 4 : 8;\n    return hwConcurrency >= minCount;\n})();\n// Prevent canvases from getting too large on ridiculous screen sizes.\n// 8K - can restrict this if needed\nconst MAX_WIDTH = 7680;\nconst MAX_HEIGHT = 4320;\nconst GRAVITY = 0.9; // Acceleration in px/s\nlet simSpeed = 1;\n\nfunction getDefaultScaleFactor() {\n    if (IS_MOBILE) return 0.9;\n    if (IS_HEADER) return 0.75;\n    return 1;\n}\n\n// Width/height values that take scale into account.\n// USE THESE FOR DRAWING POSITIONS\nlet stageW, stageH;\n\n// All quality globals will be overwritten and updated via `configDidUpdate`.\nlet quality = 1;\nlet isLowQuality = false;\nlet isNormalQuality = true;\nlet isHighQuality = false;\n\nconst QUALITY_LOW = 1;\nconst QUALITY_NORMAL = 2;\nconst QUALITY_HIGH = 3;\n\nconst SKY_LIGHT_NONE = 0;\nconst SKY_LIGHT_DIM = 1;\nconst SKY_LIGHT_NORMAL = 2;\n\nconst COLOR = {\n    Red: '#ff0043',\n    Green: '#14fc56',\n    Blue: '#1e7fff',\n    Purple: '#e60aff',\n    Gold: '#ffbf36',\n    White: '#ffffff'\n};\n\n// Special invisible color (not rendered, and therefore not in COLOR map)\nconst INVISIBLE = '_INVISIBLE_';\n\nconst PI_2 = Math.PI * 2;\nconst PI_HALF = Math.PI * 0.5;\n\n// Stage.disableHighDPI = true;\nconst trailsStage = new Stage('trails-canvas');\nconst mainStage = new Stage('main-canvas');\nconst stages = [\n    trailsStage,\n    mainStage\n];\n\n\n\n// Fullscreen helpers, using Fscreen for prefixes.\nfunction fullscreenEnabled() {\n    return fscreen.fullscreenEnabled;\n}\n\n// Note that fullscreen state is synced to store, and the store should be the source\n// of truth for whether the app is in fullscreen mode or not.\nfunction isFullscreen() {\n    return !!fscreen.fullscreenElement;\n}\n\n// Attempt to toggle fullscreen mode.\nfunction toggleFullscreen() {\n    if (fullscreenEnabled()) {\n        if (isFullscreen()) {\n            fscreen.exitFullscreen();\n        } else {\n            fscreen.requestFullscreen(document.documentElement);\n        }\n    }\n}\n\n// Sync fullscreen changes with store. An event listener is necessary because the user can\n// toggle fullscreen mode directly through the browser, and we want to react to that.\nfscreen.addEventListener('fullscreenchange', () => {\n    store.setState({\n        fullscreen: isFullscreen()\n    });\n});\n\n\n\n\n// Simple state container; the source of truth.\nconst store = {\n    _listeners: new Set(),\n    _dispatch(prevState) {\n        this._listeners.forEach(listener => listener(this.state, prevState))\n    },\n\n    state: {\n        // will be unpaused in init()\n        paused: true,\n        soundEnabled: true,\n        menuOpen: false,\n        openHelpTopic: null,\n        fullscreen: isFullscreen(),\n        // Note that config values used for <select>s must be strings, unless manually converting values to strings\n        // at render time, and parsing on change.\n        config: {\n            quality: String(IS_HIGH_END_DEVICE ? QUALITY_HIGH : QUALITY_NORMAL), // will be mirrored to a global variable named `quality` in `configDidUpdate`, for perf.\n            shell: 'Random',\n            size: IS_DESKTOP ?\n                '3' // Desktop default\n                :\n                IS_HEADER ?\n                '1.2' // Profile header default (doesn't need to be an int)\n                :\n                '2', // Mobile default\n            autoLaunch: false,\n            finale: false,\n            skyLighting: SKY_LIGHT_NORMAL + '',\n            hideControls: IS_HEADER,\n            longExposure: false,\n            scaleFactor: getDefaultScaleFactor()\n        }\n    },\n\n    setState(nextState) {\n        const prevState = this.state;\n        this.state = Object.assign({}, this.state, nextState);\n        this._dispatch(prevState);\n        this.persist();\n    },\n\n    subscribe(listener) {\n        this._listeners.add(listener);\n        return () => this._listeners.remove(listener);\n    },\n\n    // Load / persist select state to localStorage\n    // Mutates state because `store.load()` should only be called once immediately after store is created, before any subscriptions.\n    load() {\n        const serializedData = localStorage.getItem('cm_fireworks_data');\n        if (serializedData) {\n            const {\n                schemaVersion,\n                data\n            } = JSON.parse(serializedData);\n\n            const config = this.state.config;\n            switch (schemaVersion) {\n                case '1.1':\n                    config.quality = data.quality;\n                    config.size = data.size;\n                    config.skyLighting = data.skyLighting;\n                    break;\n                case '1.2':\n                    config.quality = data.quality;\n                    config.size = data.size;\n                    config.skyLighting = data.skyLighting;\n                    config.scaleFactor = data.scaleFactor;\n                    break;\n                default:\n                    throw new Error('version switch should be exhaustive');\n            }\n            console.log(`Loaded config (schema version ${schemaVersion})`);\n        }\n        // Deprecated data format. Checked with care (it's not namespaced).\n        else if (localStorage.getItem('schemaVersion') === '1') {\n            let size;\n            // Attempt to parse data, ignoring if there is an error.\n            try {\n                const sizeRaw = localStorage.getItem('configSize');\n                size = typeof sizeRaw === 'string' && JSON.parse(sizeRaw);\n            } catch (e) {\n                console.log('Recovered from error parsing saved config:');\n                console.error(e);\n                return;\n            }\n            // Only restore validated values\n            const sizeInt = parseInt(size, 10);\n            if (sizeInt >= 0 && sizeInt <= 4) {\n                this.state.config.size = String(sizeInt);\n            }\n        }\n    },\n\n    persist() {\n        const config = this.state.config;\n        localStorage.setItem('cm_fireworks_data', JSON.stringify({\n            schemaVersion: '1.2',\n            data: {\n                quality: config.quality,\n                size: config.size,\n                skyLighting: config.skyLighting,\n                scaleFactor: config.scaleFactor\n            }\n        }));\n    }\n};\n\n\nif (!IS_HEADER) {\n    store.load();\n}\n\n// Actions\n// ---------\n\nfunction togglePause(toggle) {\n    const paused = store.state.paused;\n    let newValue;\n    if (typeof toggle === 'boolean') {\n        newValue = toggle;\n    } else {\n        newValue = !paused;\n    }\n\n    if (paused !== newValue) {\n        store.setState({\n            paused: newValue\n        });\n    }\n}\n\nfunction toggleSound(toggle) {\n    if (typeof toggle === 'boolean') {\n        store.setState({\n            soundEnabled: toggle\n        });\n    } else {\n        store.setState({\n            soundEnabled: !store.state.soundEnabled\n        });\n    }\n}\n\nfunction toggleMenu(toggle) {\n    if (typeof toggle === 'boolean') {\n        store.setState({\n            menuOpen: toggle\n        });\n    } else {\n        store.setState({\n            menuOpen: !store.state.menuOpen\n        });\n    }\n}\n\nfunction updateConfig(nextConfig) {\n    nextConfig = nextConfig || getConfigFromDOM();\n    store.setState({\n        config: Object.assign({}, store.state.config, nextConfig)\n    });\n\n    configDidUpdate();\n}\n\n// Map config to various properties & apply side effects\nfunction configDidUpdate() {\n    const config = store.state.config;\n\n    quality = qualitySelector();\n    isLowQuality = quality === QUALITY_LOW;\n    isNormalQuality = quality === QUALITY_NORMAL;\n    isHighQuality = quality === QUALITY_HIGH;\n\n    if (skyLightingSelector() === SKY_LIGHT_NONE) {\n        appNodes.canvasContainer.style.backgroundColor = '#000';\n    }\n\n    Spark.drawWidth = quality === QUALITY_HIGH ? 0.75 : 1;\n}\n\n// Selectors\n// -----------\n\nconst isRunning = (state = store.state) => !state.paused && !state.menuOpen;\n// Whether user has enabled sound.\nconst soundEnabledSelector = (state = store.state) => state.soundEnabled;\n// Whether any sounds are allowed, taking into account multiple factors.\nconst canPlaySoundSelector = (state = store.state) => isRunning(state) && soundEnabledSelector(state);\n// Convert quality to number.\nconst qualitySelector = () => +store.state.config.quality;\nconst shellNameSelector = () => store.state.config.shell;\n// Convert shell size to number.\nconst shellSizeSelector = () => +store.state.config.size;\nconst finaleSelector = () => store.state.config.finale;\nconst skyLightingSelector = () => +store.state.config.skyLighting;\nconst scaleFactorSelector = () => store.state.config.scaleFactor;\n\n\n\n// Help Content\nconst helpContent = {\n    shellType: {\n        header: '烟花类型',\n        body: '选择将要发射的烟花类型。 选择“随机”是一个不错的选择！'\n    },\n    shellSize: {\n        header: '烟花大小',\n        body: '烟花的大小：以真实的烟花炮弹尺寸为模型，较大的炮弹具有更大的爆发力，带有更多的星星，有时效果更复杂。 但是，较大的尺寸还需要更多的处理能力，并且可能会导致延迟。'\n    },\n    quality: {\n        header: '画质',\n        body: '整体图形质量。 如果动画运行不流畅，请尝试降低质量。 高质量会大大增加产生的火花数量，并可能导致滞后。'\n    },\n    skyLighting: {\n        header: '天空照明',\n        body: '烟花爆炸时照亮背景。 如果背景在屏幕上看起来太亮，请尝试将其设置为“暗淡”或“无”。'\n    },\n    scaleFactor: {\n        header: '规模',\n        body: '允许缩放所有烟花的大小，实质上使您靠近或远离。 对于较大的烟花类型，可以稍微减小比例，尤其是在手机或平板电脑上。'\n    },\n    autoLaunch: {\n        header: '自动发射',\n        body: '启用此选项即可自动启动烟花序列，取消勾选你就可以手动控制烟花的发射'\n    },\n    finaleMode: {\n        header: '结局模式',\n        body: '发射强烈的烟花。 可能会导致延迟。 需要同时启用“自动发射”。'\n    },\n    hideControls: {\n        header: '隐藏控制器',\n        body: '隐藏屏幕顶部的半透明控件。 对于屏幕截图很有用，或者只是更无缝的体验。 隐藏后，您仍然可以点击右上角以重新打开此菜单。'\n    },\n    fullscreen: {\n        header: '全屏',\n        body: '切换全屏模式。'\n    },\n    longExposure: {\n        header: '打开快门',\n        body: '实验效果可以保留长时间的光线，类似于保持相机快门打开。'\n    }\n};\n\nconst nodeKeyToHelpKey = {\n    shellTypeLabel: 'shellType',\n    shellSizeLabel: 'shellSize',\n    qualityLabel: 'quality',\n    skyLightingLabel: 'skyLighting',\n    scaleFactorLabel: 'scaleFactor',\n    autoLaunchLabel: 'autoLaunch',\n    finaleModeLabel: 'finaleMode',\n    hideControlsLabel: 'hideControls',\n    fullscreenLabel: 'fullscreen',\n    longExposureLabel: 'longExposure'\n};\n\n\n// Render app UI / keep in sync with state\nconst appNodes = {\n    stageContainer: '.stage-container',\n    canvasContainer: '.canvas-container',\n    controls: '.controls',\n    menu: '.menu',\n    menuInnerWrap: '.menu__inner-wrap',\n    pauseBtn: '.pause-btn',\n    pauseBtnSVG: '.pause-btn use',\n    soundBtn: '.sound-btn',\n    soundBtnSVG: '.sound-btn use',\n    shellType: '.shell-type',\n    shellTypeLabel: '.shell-type-label',\n    shellSize: '.shell-size',\n    shellSizeLabel: '.shell-size-label',\n    quality: '.quality-ui',\n    qualityLabel: '.quality-ui-label',\n    skyLighting: '.sky-lighting',\n    skyLightingLabel: '.sky-lighting-label',\n    scaleFactor: '.scaleFactor',\n    scaleFactorLabel: '.scaleFactor-label',\n    autoLaunch: '.auto-launch',\n    autoLaunchLabel: '.auto-launch-label',\n    finaleModeFormOption: '.form-option--finale-mode',\n    finaleMode: '.finale-mode',\n    finaleModeLabel: '.finale-mode-label',\n    hideControls: '.hide-controls',\n    hideControlsLabel: '.hide-controls-label',\n    fullscreenFormOption: '.form-option--fullscreen',\n    fullscreen: '.fullscreen',\n    fullscreenLabel: '.fullscreen-label',\n    longExposure: '.long-exposure',\n    longExposureLabel: '.long-exposure-label',\n\n    // Help UI\n    helpModal: '.help-modal',\n    helpModalOverlay: '.help-modal__overlay',\n    helpModalHeader: '.help-modal__header',\n    helpModalBody: '.help-modal__body',\n    helpModalCloseBtn: '.help-modal__close-btn'\n};\n\n// Convert appNodes selectors to dom nodes\nObject.keys(appNodes).forEach(key => {\n    appNodes[key] = document.querySelector(appNodes[key]);\n});\n\n// Remove fullscreen control if not supported.\nif (!fullscreenEnabled()) {\n    appNodes.fullscreenFormOption.classList.add('remove');\n}\n\n// First render is called in init()\nfunction renderApp(state) {\n    const pauseBtnIcon = `#icon-${state.paused ? 'play' : 'pause'}`;\n    const soundBtnIcon = `#icon-sound-${soundEnabledSelector() ? 'on' : 'off'}`;\n    /*\n    appNodes.pauseBtnSVG.setAttribute('href', pauseBtnIcon);\n    appNodes.pauseBtnSVG.setAttribute('xlink:href', pauseBtnIcon);\n    appNodes.soundBtnSVG.setAttribute('href', soundBtnIcon);\n    appNodes.soundBtnSVG.setAttribute('xlink:href', soundBtnIcon);\n    appNodes.controls.classList.toggle('hide', state.menuOpen || state.config.hideControls);\n    appNodes.canvasContainer.classList.toggle('blur', state.menuOpen);\n    appNodes.menu.classList.toggle('hide', !state.menuOpen);\n    appNodes.finaleModeFormOption.style.opacity = state.config.autoLaunch ? 1 : 0.32;\n    */\n    appNodes.quality.value = state.config.quality;\n    appNodes.shellType.value = state.config.shell;\n    appNodes.shellSize.value = state.config.size;\n    appNodes.autoLaunch.checked = state.config.autoLaunch;\n    appNodes.finaleMode.checked = state.config.finale;\n    appNodes.skyLighting.value = state.config.skyLighting;\n    appNodes.hideControls.checked = state.config.hideControls;\n    appNodes.fullscreen.checked = state.fullscreen;\n    appNodes.longExposure.checked = state.config.longExposure;\n    appNodes.scaleFactor.value = state.config.scaleFactor.toFixed(2);\n\n    appNodes.menuInnerWrap.style.opacity = state.openHelpTopic ? 0.12 : 1;\n    appNodes.helpModal.classList.toggle('active', !!state.openHelpTopic);\n    if (state.openHelpTopic) {\n        const {\n            header,\n            body\n        } = helpContent[state.openHelpTopic];\n        appNodes.helpModalHeader.textContent = header;\n        appNodes.helpModalBody.textContent = body;\n    }\n}\n\nstore.subscribe(renderApp);\n\n// Perform side effects on state changes\nfunction handleStateChange(state, prevState) {\n    const canPlaySound = canPlaySoundSelector(state);\n    const canPlaySoundPrev = canPlaySoundSelector(prevState);\n\n    if (canPlaySound !== canPlaySoundPrev) {\n        if (canPlaySound) {\n            soundManager.resumeAll();\n        } else {\n            soundManager.pauseAll();\n        }\n    }\n}\n\nstore.subscribe(handleStateChange);\n\n\nfunction getConfigFromDOM() {\n    return {\n        quality: appNodes.quality.value,\n        shell: appNodes.shellType.value,\n        size: appNodes.shellSize.value,\n        autoLaunch: appNodes.autoLaunch.checked,\n        finale: appNodes.finaleMode.checked,\n        skyLighting: appNodes.skyLighting.value,\n        longExposure: appNodes.longExposure.checked,\n        hideControls: appNodes.hideControls.checked,\n        // Store value as number.\n        scaleFactor: parseFloat(appNodes.scaleFactor.value)\n    };\n};\n\nconst updateConfigNoEvent = () => updateConfig();\nappNodes.quality.addEventListener('input', updateConfigNoEvent);\nappNodes.shellType.addEventListener('input', updateConfigNoEvent);\nappNodes.shellSize.addEventListener('input', updateConfigNoEvent);\nappNodes.autoLaunch.addEventListener('click', () => setTimeout(updateConfig, 0));\nappNodes.finaleMode.addEventListener('click', () => setTimeout(updateConfig, 0));\nappNodes.skyLighting.addEventListener('input', updateConfigNoEvent);\nappNodes.longExposure.addEventListener('click', () => setTimeout(updateConfig, 0));\nappNodes.hideControls.addEventListener('click', () => setTimeout(updateConfig, 0));\nappNodes.fullscreen.addEventListener('click', () => setTimeout(toggleFullscreen, 0));\n// Changing scaleFactor requires triggering resize handling code as well.\nappNodes.scaleFactor.addEventListener('input', () => {\n    updateConfig();\n    handleResize();\n});\n\nObject.keys(nodeKeyToHelpKey).forEach(nodeKey => {\n    const helpKey = nodeKeyToHelpKey[nodeKey];\n    appNodes[nodeKey].addEventListener('click', () => {\n        store.setState({\n            openHelpTopic: helpKey\n        });\n    });\n});\n\nappNodes.helpModalCloseBtn.addEventListener('click', () => {\n    store.setState({\n        openHelpTopic: null\n    });\n});\n\nappNodes.helpModalOverlay.addEventListener('click', () => {\n    store.setState({\n        openHelpTopic: null\n    });\n});\n\n\n\n// Constant derivations\nconst COLOR_NAMES = Object.keys(COLOR);\nconst COLOR_CODES = COLOR_NAMES.map(colorName => COLOR[colorName]);\n// Invisible stars need an indentifier, even through they won't be rendered - physics still apply.\nconst COLOR_CODES_W_INVIS = [...COLOR_CODES, INVISIBLE];\n// Map of color codes to their index in the array. Useful for quickly determining if a color has already been updated in a loop.\nconst COLOR_CODE_INDEXES = COLOR_CODES_W_INVIS.reduce((obj, code, i) => {\n    obj[code] = i;\n    return obj;\n}, {});\n// Tuples is a map keys by color codes (hex) with values of { r, g, b } tuples (still just objects).\nconst COLOR_TUPLES = {};\nCOLOR_CODES.forEach(hex => {\n    COLOR_TUPLES[hex] = {\n        r: parseInt(hex.substr(1, 2), 16),\n        g: parseInt(hex.substr(3, 2), 16),\n        b: parseInt(hex.substr(5, 2), 16),\n    };\n});\n\n// Get a random color.\nfunction randomColorSimple() {\n    return COLOR_CODES[Math.random() * COLOR_CODES.length | 0];\n}\n\n// Get a random color, with some customization options available.\nlet lastColor;\n\nfunction randomColor(options) {\n    const notSame = options && options.notSame;\n    const notColor = options && options.notColor;\n    const limitWhite = options && options.limitWhite;\n    let color = randomColorSimple();\n\n    // limit the amount of white chosen randomly\n    if (limitWhite && color === COLOR.White && Math.random() < 0.6) {\n        color = randomColorSimple();\n    }\n\n    if (notSame) {\n        while (color === lastColor) {\n            color = randomColorSimple();\n        }\n    } else if (notColor) {\n        while (color === notColor) {\n            color = randomColorSimple();\n        }\n    }\n\n    lastColor = color;\n    return color;\n}\n\nfunction whiteOrGold() {\n    return Math.random() < 0.5 ? COLOR.Gold : COLOR.White;\n}\n\n\n// Shell helpers\nfunction makePistilColor(shellColor) {\n    return (shellColor === COLOR.White || shellColor === COLOR.Gold) ? randomColor({\n        notColor: shellColor\n    }) : whiteOrGold();\n}\n\n// Unique shell types\nconst crysanthemumShell = (size = 1) => {\n    const glitter = Math.random() < 0.25;\n    const singleColor = Math.random() < 0.72;\n    const color = singleColor ? randomColor({\n        limitWhite: true\n    }) : [randomColor(), randomColor({\n        notSame: true\n    })];\n    const pistil = singleColor && Math.random() < 0.42;\n    const pistilColor = pistil && makePistilColor(color);\n    const secondColor = singleColor && (Math.random() < 0.2 || color === COLOR.White) ? pistilColor || randomColor({\n        notColor: color,\n        limitWhite: true\n    }) : null;\n    const streamers = !pistil && color !== COLOR.White && Math.random() < 0.42;\n    let starDensity = glitter ? 1.1 : 1.25;\n    if (isLowQuality) starDensity *= 0.8;\n    if (isHighQuality) starDensity = 1.2;\n    return {\n        shellSize: size,\n        spreadSize: 300 + size * 100,\n        starLife: 900 + size * 200,\n        starDensity,\n        color,\n        secondColor,\n        glitter: glitter ? 'light' : '',\n        glitterColor: whiteOrGold(),\n        pistil,\n        pistilColor,\n        streamers\n    };\n};\n\n\nconst ghostShell = (size = 1) => {\n    // Extend crysanthemum shell\n    const shell = crysanthemumShell(size);\n    // Ghost effect can be fast, so extend star life\n    shell.starLife *= 1.5;\n    // Ensure we always have a single color other than white\n    let ghostColor = randomColor({\n        notColor: COLOR.White\n    });\n    // Always use streamers, and sometimes a pistil\n    shell.streamers = true;\n    const pistil = Math.random() < 0.42;\n    const pistilColor = pistil && makePistilColor(ghostColor);\n    // Ghost effect - transition from invisible to chosen color\n    shell.color = INVISIBLE;\n    shell.secondColor = ghostColor;\n    // We don't want glitter to be spewed by invisible stars, and we don't currently\n    // have a way to transition glitter state. So we'll disable it.\n    shell.glitter = '';\n\n    return shell;\n};\n\n\nconst strobeShell = (size = 1) => {\n    const color = randomColor({\n        limitWhite: true\n    });\n    return {\n        shellSize: size,\n        spreadSize: 280 + size * 92,\n        starLife: 1100 + size * 200,\n        starLifeVariation: 0.40,\n        starDensity: 1.1,\n        color,\n        glitter: 'light',\n        glitterColor: COLOR.White,\n        strobe: true,\n        strobeColor: Math.random() < 0.5 ? COLOR.White : null,\n        pistil: Math.random() < 0.5,\n        pistilColor: makePistilColor(color)\n    };\n};\n\n\nconst palmShell = (size = 1) => {\n    const color = randomColor();\n    const thick = Math.random() < 0.5;\n    return {\n        shellSize: size,\n        color,\n        spreadSize: 250 + size * 75,\n        starDensity: thick ? 0.15 : 0.4,\n        starLife: 1800 + size * 200,\n        glitter: thick ? 'thick' : 'heavy'\n    };\n};\n\nconst ringShell = (size = 1) => {\n    const color = randomColor();\n    const pistil = Math.random() < 0.75;\n    return {\n        shellSize: size,\n        ring: true,\n        color,\n        spreadSize: 300 + size * 100,\n        starLife: 900 + size * 200,\n        starCount: 2.2 * PI_2 * (size + 1),\n        pistil,\n        pistilColor: makePistilColor(color),\n        glitter: !pistil ? 'light' : '',\n        glitterColor: color === COLOR.Gold ? COLOR.Gold : COLOR.White,\n        streamers: Math.random() < 0.3\n    };\n    // return Object.assign({}, defaultShell, config);\n};\n\nconst crossetteShell = (size = 1) => {\n    const color = randomColor({\n        limitWhite: true\n    });\n    return {\n        shellSize: size,\n        spreadSize: 300 + size * 100,\n        starLife: 750 + size * 160,\n        starLifeVariation: 0.4,\n        starDensity: 0.85,\n        color,\n        crossette: true,\n        pistil: Math.random() < 0.5,\n        pistilColor: makePistilColor(color)\n    };\n};\n\nconst floralShell = (size = 1) => ({\n    shellSize: size,\n    spreadSize: 300 + size * 120,\n    starDensity: 0.12,\n    starLife: 500 + size * 50,\n    starLifeVariation: 0.5,\n    color: Math.random() < 0.65 ? 'random' : (Math.random() < 0.15 ? randomColor() : [randomColor(), randomColor({\n        notSame: true\n    })]),\n    floral: true\n});\n\nconst fallingLeavesShell = (size = 1) => ({\n    shellSize: size,\n    color: INVISIBLE,\n    spreadSize: 300 + size * 120,\n    starDensity: 0.12,\n    starLife: 500 + size * 50,\n    starLifeVariation: 0.5,\n    glitter: 'medium',\n    glitterColor: COLOR.Gold,\n    fallingLeaves: true\n});\n\nconst willowShell = (size = 1) => ({\n    shellSize: size,\n    spreadSize: 300 + size * 100,\n    starDensity: 0.6,\n    starLife: 3000 + size * 300,\n    glitter: 'willow',\n    glitterColor: COLOR.Gold,\n    color: INVISIBLE\n});\n\nconst crackleShell = (size = 1) => {\n    // favor gold\n    const color = Math.random() < 0.75 ? COLOR.Gold : randomColor();\n    return {\n        shellSize: size,\n        spreadSize: 380 + size * 75,\n        starDensity: isLowQuality ? 0.65 : 1,\n        starLife: 600 + size * 100,\n        starLifeVariation: 0.32,\n        glitter: 'light',\n        glitterColor: COLOR.Gold,\n        color,\n        crackle: true,\n        pistil: Math.random() < 0.65,\n        pistilColor: makePistilColor(color)\n    };\n};\n\nconst horsetailShell = (size = 1) => {\n    const color = randomColor();\n    return {\n        shellSize: size,\n        horsetail: true,\n        color,\n        spreadSize: 250 + size * 38,\n        starDensity: 0.9,\n        starLife: 2500 + size * 300,\n        glitter: 'medium',\n        glitterColor: Math.random() < 0.5 ? whiteOrGold() : color,\n        // Add strobe effect to white horsetails, to make them more interesting\n        strobe: color === COLOR.White\n    };\n};\n\nfunction randomShellName() {\n    return Math.random() < 0.5 ? 'Crysanthemum' : shellNames[(Math.random() * (shellNames.length - 1) + 1) | 0];\n}\n\nfunction randomShell(size) {\n    // Special selection for codepen header.\n    if (IS_HEADER) return randomFastShell()(size);\n    // Normal operation\n    return shellTypes[randomShellName()](size);\n}\n\nfunction shellFromConfig(size) {\n    return shellTypes[shellNameSelector()](size);\n}\n\n// Get a random shell, not including processing intensive varients\n// Note this is only random when \"Random\" shell is selected in config.\n// Also, this does not create the shell, only returns the factory function.\nconst fastShellBlacklist = ['Falling Leaves', 'Floral', 'Willow'];\n\nfunction randomFastShell() {\n    const isRandom = shellNameSelector() === 'Random';\n    let shellName = isRandom ? randomShellName() : shellNameSelector();\n    if (isRandom) {\n        while (fastShellBlacklist.includes(shellName)) {\n            shellName = randomShellName();\n        }\n    }\n    return shellTypes[shellName];\n}\n\n\nconst shellTypes = {\n    'Random': randomShell,\n    'Crackle': crackleShell,\n    'Crossette': crossetteShell,\n    'Crysanthemum': crysanthemumShell,\n    'Falling Leaves': fallingLeavesShell,\n    'Floral': floralShell,\n    'Ghost': ghostShell,\n    'Horse Tail': horsetailShell,\n    'Palm': palmShell,\n    'Ring': ringShell,\n    'Strobe': strobeShell,\n    'Willow': willowShell\n};\n\nconst shellNames = Object.keys(shellTypes);\n\nfunction init() {\n    // Remove loading state\n    document.querySelector('.loading-init').remove();\n    appNodes.stageContainer.classList.remove('remove');\n\n    // Populate dropdowns\n    function setOptionsForSelect(node, options) {\n        node.innerHTML = options.reduce((acc, opt) => acc += `<option value=\"${opt.value}\">${opt.label}</option>`, '');\n    }\n\n    // shell type\n    let options = '';\n    shellNames.forEach(opt => options += `<option value=\"${opt}\">${opt}</option>`);\n    appNodes.shellType.innerHTML = options;\n    // shell size\n    options = '';\n    ['3\"', '4\"', '6\"', '8\"', '12\"', '16\"'].forEach((opt, i) => options += `<option value=\"${i}\">${opt}</option>`);\n    appNodes.shellSize.innerHTML = options;\n\n    setOptionsForSelect(appNodes.quality, [{\n            label: '低',\n            value: QUALITY_LOW\n        },\n        {\n            label: '正常',\n            value: QUALITY_NORMAL\n        },\n        {\n            label: '高',\n            value: QUALITY_HIGH\n        }\n    ]);\n\n    setOptionsForSelect(appNodes.skyLighting, [{\n            label: '无',\n            value: SKY_LIGHT_NONE\n        },\n        {\n            label: '暗淡',\n            value: SKY_LIGHT_DIM\n        },\n        {\n            label: '正常',\n            value: SKY_LIGHT_NORMAL\n        }\n    ]);\n\n    // 0.9 is mobile default\n    setOptionsForSelect(\n        appNodes.scaleFactor,\n        [0.5, 0.62, 0.75, 0.9, 1.0, 1.5, 2.0]\n        .map(value => ({\n            value: value.toFixed(2),\n            label: `${value*100}%`\n        }))\n    );\n\n    // Begin simulation\n    togglePause(false);\n\n    // initial render\n    renderApp(store.state);\n\n    // Apply initial config\n    configDidUpdate();\n}\n\n\nfunction fitShellPositionInBoundsH(position) {\n    const edge = 0.18;\n    return (1 - edge * 2) * position + edge;\n}\n\nfunction fitShellPositionInBoundsV(position) {\n    return position * 0.75;\n}\n\nfunction getRandomShellPositionH() {\n    return fitShellPositionInBoundsH(Math.random());\n}\n\nfunction getRandomShellPositionV() {\n    return fitShellPositionInBoundsV(Math.random());\n}\n\nfunction getRandomShellSize() {\n    const baseSize = shellSizeSelector();\n    const maxVariance = Math.min(2.5, baseSize);\n    const variance = Math.random() * maxVariance;\n    const size = baseSize - variance;\n    const height = maxVariance === 0 ? Math.random() : 1 - (variance / maxVariance);\n    const centerOffset = Math.random() * (1 - height * 0.65) * 0.5;\n    const x = Math.random() < 0.5 ? 0.5 - centerOffset : 0.5 + centerOffset;\n    return {\n        size,\n        x: fitShellPositionInBoundsH(x),\n        height: fitShellPositionInBoundsV(height)\n    };\n}\n\n\n// Launches a shell from a user pointer event, based on state.config\nfunction launchShellFromConfig(event) {\n    const shell = new Shell(shellFromConfig(shellSizeSelector()));\n    const w = mainStage.width;\n    const h = mainStage.height;\n\n    shell.launch(\n        event ? event.x / w : getRandomShellPositionH(),\n        event ? 1 - event.y / h : getRandomShellPositionV()\n    );\n}\n\n\n// Sequences\n// -----------\n\nfunction seqRandomShell() {\n    const size = getRandomShellSize();\n    const shell = new Shell(shellFromConfig(size.size));\n    shell.launch(size.x, size.height);\n\n    let extraDelay = shell.starLife;\n    if (shell.fallingLeaves) {\n        extraDelay = 4600;\n    }\n\n    return 900 + Math.random() * 600 + extraDelay;\n}\n\nfunction seqRandomFastShell() {\n    const shellType = randomFastShell();\n    const size = getRandomShellSize();\n    const shell = new Shell(shellType(size.size));\n    shell.launch(size.x, size.height);\n\n    let extraDelay = shell.starLife;\n\n    return 900 + Math.random() * 600 + extraDelay;\n}\n\nfunction seqTwoRandom() {\n    const size1 = getRandomShellSize();\n    const size2 = getRandomShellSize();\n    const shell1 = new Shell(shellFromConfig(size1.size));\n    const shell2 = new Shell(shellFromConfig(size2.size));\n    const leftOffset = Math.random() * 0.2 - 0.1;\n    const rightOffset = Math.random() * 0.2 - 0.1;\n    shell1.launch(0.3 + leftOffset, size1.height);\n    setTimeout(() => {\n        shell2.launch(0.7 + rightOffset, size2.height);\n    }, 100);\n\n    let extraDelay = Math.max(shell1.starLife, shell2.starLife);\n    if (shell1.fallingLeaves || shell2.fallingLeaves) {\n        extraDelay = 4600;\n    }\n\n    return 900 + Math.random() * 600 + extraDelay;\n}\n\nfunction seqTriple() {\n    const shellType = randomFastShell();\n    const baseSize = shellSizeSelector();\n    const smallSize = Math.max(0, baseSize - 1.25);\n\n    const offset = Math.random() * 0.08 - 0.04;\n    const shell1 = new Shell(shellType(baseSize));\n    shell1.launch(0.5 + offset, 0.7);\n\n    const leftDelay = 1000 + Math.random() * 400;\n    const rightDelay = 1000 + Math.random() * 400;\n\n    setTimeout(() => {\n        const offset = Math.random() * 0.08 - 0.04;\n        const shell2 = new Shell(shellType(smallSize));\n        shell2.launch(0.2 + offset, 0.1);\n    }, leftDelay);\n\n    setTimeout(() => {\n        const offset = Math.random() * 0.08 - 0.04;\n        const shell3 = new Shell(shellType(smallSize));\n        shell3.launch(0.8 + offset, 0.1);\n    }, rightDelay);\n\n    return 4000;\n}\n\nfunction seqPyramid() {\n    const barrageCountHalf = IS_DESKTOP ? 7 : 4;\n    const largeSize = shellSizeSelector();\n    const smallSize = Math.max(0, largeSize - 3);\n    const randomMainShell = Math.random() < 0.78 ? crysanthemumShell : ringShell;\n    const randomSpecialShell = randomShell;\n\n    function launchShell(x, useSpecial) {\n        const isRandom = shellNameSelector() === 'Random';\n        let shellType = isRandom ?\n            useSpecial ? randomSpecialShell : randomMainShell :\n            shellTypes[shellNameSelector()];\n        const shell = new Shell(shellType(useSpecial ? largeSize : smallSize));\n        const height = x <= 0.5 ? x / 0.5 : (1 - x) / 0.5;\n        shell.launch(x, useSpecial ? 0.75 : height * 0.42);\n    }\n\n    let count = 0;\n    let delay = 0;\n    while (count <= barrageCountHalf) {\n        if (count === barrageCountHalf) {\n            setTimeout(() => {\n                launchShell(0.5, true);\n            }, delay);\n        } else {\n            const offset = count / barrageCountHalf * 0.5;\n            const delayOffset = Math.random() * 30 + 30;\n            setTimeout(() => {\n                launchShell(offset, false);\n            }, delay);\n            setTimeout(() => {\n                launchShell(1 - offset, false);\n            }, delay + delayOffset);\n        }\n\n        count++;\n        delay += 200;\n    }\n\n    return 3400 + barrageCountHalf * 250;\n}\n\nfunction seqSmallBarrage() {\n    seqSmallBarrage.lastCalled = Date.now();\n    const barrageCount = IS_DESKTOP ? 11 : 5;\n    const specialIndex = IS_DESKTOP ? 3 : 1;\n    const shellSize = Math.max(0, shellSizeSelector() - 2);\n    const randomMainShell = Math.random() < 0.78 ? crysanthemumShell : ringShell;\n    const randomSpecialShell = randomFastShell();\n\n    // (cos(x*5π+0.5π)+1)/2 is a custom wave bounded by 0 and 1 used to set varying launch heights\n    function launchShell(x, useSpecial) {\n        const isRandom = shellNameSelector() === 'Random';\n        let shellType = isRandom ?\n            useSpecial ? randomSpecialShell : randomMainShell :\n            shellTypes[shellNameSelector()];\n        const shell = new Shell(shellType(shellSize));\n        const height = (Math.cos(x * 5 * Math.PI + PI_HALF) + 1) / 2;\n        shell.launch(x, height * 0.75);\n    }\n\n    let count = 0;\n    let delay = 0;\n    while (count < barrageCount) {\n        if (count === 0) {\n            launchShell(0.5, false)\n            count += 1;\n        } else {\n            const offset = (count + 1) / barrageCount / 2;\n            const delayOffset = Math.random() * 30 + 30;\n            const useSpecial = count === specialIndex;\n            setTimeout(() => {\n                launchShell(0.5 + offset, useSpecial);\n            }, delay);\n            setTimeout(() => {\n                launchShell(0.5 - offset, useSpecial);\n            }, delay + delayOffset);\n            count += 2;\n        }\n        delay += 200;\n    }\n\n    return 3400 + barrageCount * 120;\n}\nseqSmallBarrage.cooldown = 15000;\nseqSmallBarrage.lastCalled = Date.now();\n\n\nconst sequences = [\n    seqRandomShell,\n    seqTwoRandom,\n    seqTriple,\n    seqPyramid,\n    seqSmallBarrage\n];\n\n\nlet isFirstSeq = true;\nconst finaleCount = 32;\nlet currentFinaleCount = 0;\n\nfunction startSequence() {\n    if (isFirstSeq) {\n        isFirstSeq = false;\n        if (IS_HEADER) {\n            return seqTwoRandom();\n        } else {\n            const shell = new Shell(crysanthemumShell(shellSizeSelector()));\n            shell.launch(0.5, 0.5);\n            return 2400;\n        }\n    }\n\n    if (finaleSelector()) {\n        seqRandomFastShell();\n        if (currentFinaleCount < finaleCount) {\n            currentFinaleCount++;\n            return 170;\n        } else {\n            currentFinaleCount = 0;\n            return 6000;\n        }\n    }\n\n    const rand = Math.random();\n\n    if (rand < 0.08 && Date.now() - seqSmallBarrage.lastCalled > seqSmallBarrage.cooldown) {\n        return seqSmallBarrage();\n    }\n\n    if (rand < 0.1) {\n        return seqPyramid();\n    }\n\n    if (rand < 0.6 && !IS_HEADER) {\n        return seqRandomShell();\n    } else if (rand < 0.8) {\n        return seqTwoRandom();\n    } else if (rand < 1) {\n        return seqTriple();\n    }\n}\n\n\nlet activePointerCount = 0;\nlet isUpdatingSpeed = false;\n\nfunction handlePointerStart(event) {\n    activePointerCount++;\n    const btnSize = 50;\n\n    if (event.y < btnSize) {\n        if (event.x < btnSize) {\n            togglePause();\n            return;\n        }\n        if (event.x > mainStage.width / 2 - btnSize / 2 && event.x < mainStage.width / 2 + btnSize / 2) {\n            toggleSound();\n            return;\n        }\n        if (event.x > mainStage.width - btnSize) {\n            toggleMenu();\n            return;\n        }\n    }\n\n    if (!isRunning()) return;\n\n    if (updateSpeedFromEvent(event)) {\n        isUpdatingSpeed = true;\n    } else if (event.onCanvas) {\n        launchShellFromConfig(event);\n    }\n}\n\nfunction handlePointerEnd(event) {\n    activePointerCount--;\n    isUpdatingSpeed = false;\n}\n\nfunction handlePointerMove(event) {\n    if (!isRunning()) return;\n\n    if (isUpdatingSpeed) {\n        updateSpeedFromEvent(event);\n    }\n}\n\nfunction handleKeydown(event) {\n    // P\n    if (event.keyCode === 80) {\n        togglePause();\n    }\n    // O\n    else if (event.keyCode === 79) {\n        toggleMenu();\n    }\n    // Esc\n    else if (event.keyCode === 27) {\n        toggleMenu(false);\n    }\n}\n\nmainStage.addEventListener('pointerstart', handlePointerStart);\nmainStage.addEventListener('pointerend', handlePointerEnd);\nmainStage.addEventListener('pointermove', handlePointerMove);\nwindow.addEventListener('keydown', handleKeydown);\n\n\n// Account for window resize and custom scale changes.\nfunction handleResize() {\n    const w = window.innerWidth;\n    const h = window.innerHeight;\n    // Try to adopt screen size, heeding maximum sizes specified\n    const containerW = Math.min(w, MAX_WIDTH);\n    // On small screens, use full device height\n    const containerH = w <= 420 ? h : Math.min(h, MAX_HEIGHT);\n    appNodes.stageContainer.style.width = containerW + 'px';\n    appNodes.stageContainer.style.height = containerH + 'px';\n    stages.forEach(stage => stage.resize(containerW, containerH));\n    // Account for scale\n    const scaleFactor = scaleFactorSelector();\n    stageW = containerW / scaleFactor;\n    stageH = containerH / scaleFactor;\n}\n\n// Compute initial dimensions\nhandleResize();\n\nwindow.addEventListener('resize', handleResize);\n\n\n// Dynamic globals\nlet currentFrame = 0;\nlet speedBarOpacity = 0;\nlet autoLaunchTime = 0;\n\nfunction updateSpeedFromEvent(event) {\n    if (isUpdatingSpeed || event.y >= mainStage.height - 44) {\n        // On phones it's hard to hit the edge pixels in order to set speed at 0 or 1, so some padding is provided to make that easier.\n        const edge = 16;\n        const newSpeed = (event.x - edge) / (mainStage.width - edge * 2);\n        simSpeed = Math.min(Math.max(newSpeed, 0), 1);\n        // show speed bar after an update\n        speedBarOpacity = 1;\n        // If we updated the speed, return true\n        return true;\n    }\n    // Return false if the speed wasn't updated\n    return false;\n}\n\n\n// Extracted function to keep `update()` optimized\nfunction updateGlobals(timeStep, lag) {\n    currentFrame++;\n\n    // Always try to fade out speed bar\n    if (!isUpdatingSpeed) {\n        speedBarOpacity -= lag / 30; // half a second\n        if (speedBarOpacity < 0) {\n            speedBarOpacity = 0;\n        }\n    }\n\n    // auto launch shells\n    if (store.state.config.autoLaunch) {\n        autoLaunchTime -= timeStep;\n        if (autoLaunchTime <= 0) {\n            autoLaunchTime = startSequence() * 1.25;\n        }\n    }\n}\n\n\nfunction update(frameTime, lag) {\n    if (!isRunning()) return;\n\n    const width = stageW;\n    const height = stageH;\n    const timeStep = frameTime * simSpeed;\n    const speed = simSpeed * lag;\n\n    updateGlobals(timeStep, lag);\n\n    const starDrag = 1 - (1 - Star.airDrag) * speed;\n    const starDragHeavy = 1 - (1 - Star.airDragHeavy) * speed;\n    const sparkDrag = 1 - (1 - Spark.airDrag) * speed;\n    const gAcc = timeStep / 1000 * GRAVITY;\n    COLOR_CODES_W_INVIS.forEach(color => {\n        // Stars\n        const stars = Star.active[color];\n        for (let i = stars.length - 1; i >= 0; i = i - 1) {\n            const star = stars[i];\n            // Only update each star once per frame. Since color can change, it's possible a star could update twice without this, leading to a \"jump\".\n            if (star.updateFrame === currentFrame) {\n                continue;\n            }\n            star.updateFrame = currentFrame;\n\n            star.life -= timeStep;\n            if (star.life <= 0) {\n                stars.splice(i, 1);\n                Star.returnInstance(star);\n            } else {\n                const burnRate = Math.pow(star.life / star.fullLife, 0.5);\n                const burnRateInverse = 1 - burnRate;\n\n                star.prevX = star.x;\n                star.prevY = star.y;\n                star.x += star.speedX * speed;\n                star.y += star.speedY * speed;\n                // Apply air drag if star isn't \"heavy\". The heavy property is used for the shell comets.\n                if (!star.heavy) {\n                    star.speedX *= starDrag;\n                    star.speedY *= starDrag;\n                } else {\n                    star.speedX *= starDragHeavy;\n                    star.speedY *= starDragHeavy;\n                }\n                star.speedY += gAcc;\n\n                if (star.spinRadius) {\n                    star.spinAngle += star.spinSpeed * speed;\n                    star.x += Math.sin(star.spinAngle) * star.spinRadius * speed;\n                    star.y += Math.cos(star.spinAngle) * star.spinRadius * speed;\n                }\n\n                if (star.sparkFreq) {\n                    star.sparkTimer -= timeStep;\n                    while (star.sparkTimer < 0) {\n                        star.sparkTimer += star.sparkFreq * 0.75 + star.sparkFreq * burnRateInverse * 4;\n                        Spark.add(\n                            star.x,\n                            star.y,\n                            star.sparkColor,\n                            Math.random() * PI_2,\n                            Math.random() * star.sparkSpeed * burnRate,\n                            star.sparkLife * 0.8 + Math.random() * star.sparkLifeVariation * star.sparkLife\n                        );\n                    }\n                }\n\n                // Handle star transitions\n                if (star.life < star.transitionTime) {\n                    if (star.secondColor && !star.colorChanged) {\n                        star.colorChanged = true;\n                        star.color = star.secondColor;\n                        stars.splice(i, 1);\n                        Star.active[star.secondColor].push(star);\n                        if (star.secondColor === INVISIBLE) {\n                            star.sparkFreq = 0;\n                        }\n                    }\n\n                    if (star.strobe) {\n                        // Strobes in the following pattern: on:off:off:on:off:off in increments of `strobeFreq` ms.\n                        star.visible = Math.floor(star.life / star.strobeFreq) % 3 === 0;\n                    }\n                }\n            }\n        }\n\n        // Sparks\n        const sparks = Spark.active[color];\n        for (let i = sparks.length - 1; i >= 0; i = i - 1) {\n            const spark = sparks[i];\n            spark.life -= timeStep;\n            if (spark.life <= 0) {\n                sparks.splice(i, 1);\n                Spark.returnInstance(spark);\n            } else {\n                spark.prevX = spark.x;\n                spark.prevY = spark.y;\n                spark.x += spark.speedX * speed;\n                spark.y += spark.speedY * speed;\n                spark.speedX *= sparkDrag;\n                spark.speedY *= sparkDrag;\n                spark.speedY += gAcc;\n            }\n        }\n    });\n\n    render(speed);\n}\n\nfunction render(speed) {\n    const {\n        dpr\n    } = mainStage;\n    const width = stageW;\n    const height = stageH;\n    const trailsCtx = trailsStage.ctx;\n    const mainCtx = mainStage.ctx;\n\n    if (skyLightingSelector() !== SKY_LIGHT_NONE) {\n        colorSky(speed);\n    }\n\n    // Account for high DPI screens, and custom scale factor.\n    const scaleFactor = scaleFactorSelector();\n    trailsCtx.scale(dpr * scaleFactor, dpr * scaleFactor);\n    mainCtx.scale(dpr * scaleFactor, dpr * scaleFactor);\n\n    trailsCtx.globalCompositeOperation = 'source-over';\n    trailsCtx.fillStyle = `rgba(0, 0, 0, ${store.state.config.longExposure ? 0.0025 : 0.175 * speed})`;\n    trailsCtx.fillRect(0, 0, width, height);\n\n    mainCtx.clearRect(0, 0, width, height);\n\n    // Draw queued burst flashes\n    // These must also be drawn using source-over due to Safari. Seems rendering the gradients using lighten draws large black boxes instead.\n    // Thankfully, these burst flashes look pretty much the same either way.\n    while (BurstFlash.active.length) {\n        const bf = BurstFlash.active.pop();\n\n        const burstGradient = trailsCtx.createRadialGradient(bf.x, bf.y, 0, bf.x, bf.y, bf.radius);\n        burstGradient.addColorStop(0.024, 'rgba(255, 255, 255, 1)');\n        burstGradient.addColorStop(0.125, 'rgba(255, 160, 20, 0.2)');\n        burstGradient.addColorStop(0.32, 'rgba(255, 140, 20, 0.11)');\n        burstGradient.addColorStop(1, 'rgba(255, 120, 20, 0)');\n        trailsCtx.fillStyle = burstGradient;\n        trailsCtx.fillRect(bf.x - bf.radius, bf.y - bf.radius, bf.radius * 2, bf.radius * 2);\n\n        BurstFlash.returnInstance(bf);\n    }\n\n    // Remaining drawing on trails canvas will use 'lighten' blend mode\n    trailsCtx.globalCompositeOperation = 'lighten';\n\n    // Draw stars\n    trailsCtx.lineWidth = Star.drawWidth;\n    trailsCtx.lineCap = isLowQuality ? 'square' : 'round';\n    mainCtx.strokeStyle = '#fff';\n    mainCtx.lineWidth = 1;\n    mainCtx.beginPath();\n    COLOR_CODES.forEach(color => {\n        const stars = Star.active[color];\n        trailsCtx.strokeStyle = color;\n        trailsCtx.beginPath();\n        stars.forEach(star => {\n            if (star.visible) {\n                trailsCtx.moveTo(star.x, star.y);\n                trailsCtx.lineTo(star.prevX, star.prevY);\n                mainCtx.moveTo(star.x, star.y);\n                mainCtx.lineTo(star.x - star.speedX * 1.6, star.y - star.speedY * 1.6);\n            }\n        });\n        trailsCtx.stroke();\n    });\n    mainCtx.stroke();\n\n    // Draw sparks\n    trailsCtx.lineWidth = Spark.drawWidth;\n    trailsCtx.lineCap = 'butt';\n    COLOR_CODES.forEach(color => {\n        const sparks = Spark.active[color];\n        trailsCtx.strokeStyle = color;\n        trailsCtx.beginPath();\n        sparks.forEach(spark => {\n            trailsCtx.moveTo(spark.x, spark.y);\n            trailsCtx.lineTo(spark.prevX, spark.prevY);\n        });\n        trailsCtx.stroke();\n    });\n\n\n    // Render speed bar if visible\n    if (speedBarOpacity) {\n        const speedBarHeight = 6;\n        mainCtx.globalAlpha = speedBarOpacity;\n        mainCtx.fillStyle = COLOR.Blue;\n        mainCtx.fillRect(0, height - speedBarHeight, width * simSpeed, speedBarHeight);\n        mainCtx.globalAlpha = 1;\n    }\n\n\n    trailsCtx.setTransform(1, 0, 0, 1, 0, 0);\n    mainCtx.setTransform(1, 0, 0, 1, 0, 0);\n}\n\n\n// Draw colored overlay based on combined brightness of stars (light up the sky!)\n// Note: this is applied to the canvas container's background-color, so it's behind the particles\nconst currentSkyColor = {\n    r: 0,\n    g: 0,\n    b: 0\n};\nconst targetSkyColor = {\n    r: 0,\n    g: 0,\n    b: 0\n};\n\nfunction colorSky(speed) {\n    // The maximum r, g, or b value that will be used (255 would represent no maximum)\n    const maxSkySaturation = skyLightingSelector() * 15;\n    // How many stars are required in total to reach maximum sky brightness\n    const maxStarCount = 500;\n    let totalStarCount = 0;\n    // Initialize sky as black\n    targetSkyColor.r = 0;\n    targetSkyColor.g = 0;\n    targetSkyColor.b = 0;\n    // Add each known color to sky, multiplied by particle count of that color. This will put RGB values wildly out of bounds, but we'll scale them back later.\n    // Also add up total star count.\n    COLOR_CODES.forEach(color => {\n        const tuple = COLOR_TUPLES[color];\n        const count = Star.active[color].length;\n        totalStarCount += count;\n        targetSkyColor.r += tuple.r * count;\n        targetSkyColor.g += tuple.g * count;\n        targetSkyColor.b += tuple.b * count;\n    });\n\n    // Clamp intensity at 1.0, and map to a custom non-linear curve. This allows few stars to perceivably light up the sky, while more stars continue to increase the brightness but at a lesser rate. This is more inline with humans' non-linear brightness perception.\n    const intensity = Math.pow(Math.min(1, totalStarCount / maxStarCount), 0.3);\n    // Figure out which color component has the highest value, so we can scale them without affecting the ratios.\n    // Prevent 0 from being used, so we don't divide by zero in the next step.\n    const maxColorComponent = Math.max(1, targetSkyColor.r, targetSkyColor.g, targetSkyColor.b);\n    // Scale all color components to a max of `maxSkySaturation`, and apply intensity.\n    targetSkyColor.r = targetSkyColor.r / maxColorComponent * maxSkySaturation * intensity;\n    targetSkyColor.g = targetSkyColor.g / maxColorComponent * maxSkySaturation * intensity;\n    targetSkyColor.b = targetSkyColor.b / maxColorComponent * maxSkySaturation * intensity;\n\n    // Animate changes to color to smooth out transitions.\n    const colorChange = 10;\n    currentSkyColor.r += (targetSkyColor.r - currentSkyColor.r) / colorChange * speed;\n    currentSkyColor.g += (targetSkyColor.g - currentSkyColor.g) / colorChange * speed;\n    currentSkyColor.b += (targetSkyColor.b - currentSkyColor.b) / colorChange * speed;\n\n    appNodes.canvasContainer.style.backgroundColor = `rgb(${currentSkyColor.r | 0}, ${currentSkyColor.g | 0}, ${currentSkyColor.b | 0})`;\n}\n\nmainStage.addEventListener('ticker', update);\n\n\n// Helper used to semi-randomly spread particles over an arc\n// Values are flexible - `start` and `arcLength` can be negative, and `randomness` is simply a multiplier for random addition.\nfunction createParticleArc(start, arcLength, count, randomness, particleFactory) {\n    const angleDelta = arcLength / count;\n    // Sometimes there is an extra particle at the end, too close to the start. Subtracting half the angleDelta ensures that is skipped.\n    // Would be nice to fix this a better way.\n    const end = start + arcLength - (angleDelta * 0.5);\n\n    if (end > start) {\n        // Optimization: `angle=angle+angleDelta` vs. angle+=angleDelta\n        // V8 deoptimises with let compound assignment\n        for (let angle = start; angle < end; angle = angle + angleDelta) {\n            particleFactory(angle + Math.random() * angleDelta * randomness);\n        }\n    } else {\n        for (let angle = start; angle > end; angle = angle + angleDelta) {\n            particleFactory(angle + Math.random() * angleDelta * randomness);\n        }\n    }\n}\n\n\n/**\n * Helper used to create a spherical burst of particles.\n *\n * @param  {Number} count               The desired number of stars/particles. This value is a suggestion, and the\n *                                      created burst may have more particles. The current algorithm can't perfectly\n *                                      distribute a specific number of points evenly on a sphere's surface.\n * @param  {Function} particleFactory   Called once per star/particle generated. Passed two arguments:\n *                                        `angle`: The direction of the star/particle.\n *                                        `speed`: A multipler for the particle speed, from 0.0 to 1.0.\n * @param  {Number} startAngle=0        For segmented bursts, you can generate only a partial arc of particles. This\n *                                      allows setting the starting arc angle (radians).\n * @param  {Number} arcLength=TAU       The length of the arc (radians). Defaults to a full circle.\n *\n * @return {void}              Returns nothing; it's up to `particleFactory` to use the given data.\n */\nfunction createBurst(count, particleFactory, startAngle = 0, arcLength = PI_2) {\n    // Assuming sphere with surface area of `count`, calculate various\n    // properties of said sphere (unit is stars).\n    // Radius\n    const R = 0.5 * Math.sqrt(count / Math.PI);\n    // Circumference\n    const C = 2 * R * Math.PI;\n    // Half Circumference\n    const C_HALF = C / 2;\n\n    // Make a series of rings, sizing them as if they were spaced evenly\n    // along the curved surface of a sphere.\n    for (let i = 0; i <= C_HALF; i++) {\n        const ringAngle = i / C_HALF * PI_HALF;\n        const ringSize = Math.cos(ringAngle);\n        const partsPerFullRing = C * ringSize;\n        const partsPerArc = partsPerFullRing * (arcLength / PI_2);\n\n        const angleInc = PI_2 / partsPerFullRing;\n        const angleOffset = Math.random() * angleInc + startAngle;\n        // Each particle needs a bit of randomness to improve appearance.\n        const maxRandomAngleOffset = angleInc * 0.33;\n\n        for (let i = 0; i < partsPerArc; i++) {\n            const randomAngleOffset = Math.random() * maxRandomAngleOffset;\n            let angle = angleInc * i + angleOffset + randomAngleOffset;\n            particleFactory(angle, ringSize);\n        }\n    }\n}\n\n\n\n\n// Various star effects.\n// These are designed to be attached to a star's `onDeath` event.\n\n// Crossette breaks star into four same-color pieces which branch in a cross-like shape.\nfunction crossetteEffect(star) {\n    const startAngle = Math.random() * PI_HALF;\n    createParticleArc(startAngle, PI_2, 4, 0.5, (angle) => {\n        Star.add(\n            star.x,\n            star.y,\n            star.color,\n            angle,\n            Math.random() * 0.6 + 0.75,\n            600\n        );\n    });\n}\n\n// Flower is like a mini shell\nfunction floralEffect(star) {\n    const count = 12 + 6 * quality;\n    createBurst(count, (angle, speedMult) => {\n        Star.add(\n            star.x,\n            star.y,\n            star.color,\n            angle,\n            speedMult * 2.4,\n            1000 + Math.random() * 300,\n            star.speedX,\n            star.speedY\n        );\n    });\n    // Queue burst flash render\n    BurstFlash.add(star.x, star.y, 46);\n    soundManager.playSound('burstSmall');\n}\n\n// Floral burst with willow stars\nfunction fallingLeavesEffect(star) {\n    createBurst(7, (angle, speedMult) => {\n        const newStar = Star.add(\n            star.x,\n            star.y,\n            INVISIBLE,\n            angle,\n            speedMult * 2.4,\n            2400 + Math.random() * 600,\n            star.speedX,\n            star.speedY\n        );\n\n        newStar.sparkColor = COLOR.Gold;\n        newStar.sparkFreq = 144 / quality;\n        newStar.sparkSpeed = 0.28;\n        newStar.sparkLife = 750;\n        newStar.sparkLifeVariation = 3.2;\n    });\n    // Queue burst flash render\n    BurstFlash.add(star.x, star.y, 46);\n    soundManager.playSound('burstSmall');\n}\n\n// Crackle pops into a small cloud of golden sparks.\nfunction crackleEffect(star) {\n    const count = isHighQuality ? 32 : 16;\n    createParticleArc(0, PI_2, count, 1.8, (angle) => {\n        Spark.add(\n            star.x,\n            star.y,\n            COLOR.Gold,\n            angle,\n            // apply near cubic falloff to speed (places more particles towards outside)\n            Math.pow(Math.random(), 0.45) * 2.4,\n            300 + Math.random() * 200\n        );\n    });\n}\n\n\n\n/**\n * Shell can be constructed with options:\n *\n * spreadSize:      Size of the burst.\n * starCount: Number of stars to create. This is optional, and will be set to a reasonable quantity for size if omitted.\n * starLife:\n * starLifeVariation:\n * color:\n * glitterColor:\n * glitter: One of: 'light', 'medium', 'heavy', 'streamer', 'willow'\n * pistil:\n * pistilColor:\n * streamers:\n * crossette:\n * floral:\n * crackle:\n */\nclass Shell {\n    constructor(options) {\n        Object.assign(this, options);\n        this.starLifeVariation = options.starLifeVariation || 0.125;\n        this.color = options.color || randomColor();\n        this.glitterColor = options.glitterColor || this.color;\n\n        // Set default starCount if needed, will be based on shell size and scale exponentially, like a sphere's surface area.\n        if (!this.starCount) {\n            const density = options.starDensity || 1;\n            const scaledSize = this.spreadSize / 54;\n            this.starCount = Math.max(6, scaledSize * scaledSize * density);\n        }\n    }\n\n    launch(position, launchHeight) {\n        const width = stageW;\n        const height = stageH;\n        // Distance from sides of screen to keep shells.\n        const hpad = 60;\n        // Distance from top of screen to keep shell bursts.\n        const vpad = 50;\n        // Minimum burst height, as a percentage of stage height\n        const minHeightPercent = 0.45;\n        // Minimum burst height in px\n        const minHeight = height - height * minHeightPercent;\n\n        const launchX = position * (width - hpad * 2) + hpad;\n        const launchY = height;\n        const burstY = minHeight - (launchHeight * (minHeight - vpad));\n\n        const launchDistance = launchY - burstY;\n        // Using a custom power curve to approximate Vi needed to reach launchDistance under gravity and air drag.\n        // Magic numbers came from testing.\n        const launchVelocity = Math.pow(launchDistance * 0.04, 0.64);\n\n        const comet = this.comet = Star.add(\n            launchX,\n            launchY,\n            typeof this.color === 'string' && this.color !== 'random' ? this.color : COLOR.White,\n            Math.PI,\n            launchVelocity * (this.horsetail ? 1.2 : 1),\n            // Hang time is derived linearly from Vi; exact number came from testing\n            launchVelocity * (this.horsetail ? 100 : 400)\n        );\n\n        // making comet \"heavy\" limits air drag\n        comet.heavy = true;\n        // comet spark trail\n        comet.spinRadius = MyMath.random(0.32, 0.85);\n        comet.sparkFreq = 32 / quality;\n        if (isHighQuality) comet.sparkFreq = 8;\n        comet.sparkLife = 320;\n        comet.sparkLifeVariation = 3;\n        if (this.glitter === 'willow' || this.fallingLeaves) {\n            comet.sparkFreq = 20 / quality;\n            comet.sparkSpeed = 0.5;\n            comet.sparkLife = 500;\n        }\n        if (this.color === INVISIBLE) {\n            comet.sparkColor = COLOR.Gold;\n        }\n\n        // Randomly make comet \"burn out\" a bit early.\n        // This is disabled for horsetail shells, due to their very short airtime.\n        if (Math.random() > 0.4 && !this.horsetail) {\n            comet.secondColor = INVISIBLE;\n            comet.transitionTime = Math.pow(Math.random(), 1.5) * 700 + 500;\n        }\n\n        comet.onDeath = comet => this.burst(comet.x, comet.y);\n\n        soundManager.playSound('lift');\n    }\n\n    burst(x, y) {\n        // Set burst speed so overall burst grows to set size. This specific formula was derived from testing, and is affected by simulated air drag.\n        const speed = this.spreadSize / 96;\n\n        let color, onDeath, sparkFreq, sparkSpeed, sparkLife;\n        let sparkLifeVariation = 0.25;\n        // Some death effects, like crackle, play a sound, but should only be played once.\n        let playedDeathSound = false;\n\n        if (this.crossette) onDeath = (star) => {\n            if (!playedDeathSound) {\n                soundManager.playSound('crackleSmall');\n                playedDeathSound = true;\n            }\n            crossetteEffect(star);\n        }\n        if (this.crackle) onDeath = (star) => {\n            if (!playedDeathSound) {\n                soundManager.playSound('crackle');\n                playedDeathSound = true;\n            }\n            crackleEffect(star);\n        }\n        if (this.floral) onDeath = floralEffect;\n        if (this.fallingLeaves) onDeath = fallingLeavesEffect;\n\n        if (this.glitter === 'light') {\n            sparkFreq = 400;\n            sparkSpeed = 0.3;\n            sparkLife = 300;\n            sparkLifeVariation = 2;\n        } else if (this.glitter === 'medium') {\n            sparkFreq = 200;\n            sparkSpeed = 0.44;\n            sparkLife = 700;\n            sparkLifeVariation = 2;\n        } else if (this.glitter === 'heavy') {\n            sparkFreq = 80;\n            sparkSpeed = 0.8;\n            sparkLife = 1400;\n            sparkLifeVariation = 2;\n        } else if (this.glitter === 'thick') {\n            sparkFreq = 16;\n            sparkSpeed = isHighQuality ? 1.65 : 1.5;\n            sparkLife = 1400;\n            sparkLifeVariation = 3;\n        } else if (this.glitter === 'streamer') {\n            sparkFreq = 32;\n            sparkSpeed = 1.05;\n            sparkLife = 620;\n            sparkLifeVariation = 2;\n        } else if (this.glitter === 'willow') {\n            sparkFreq = 120;\n            sparkSpeed = 0.34;\n            sparkLife = 1400;\n            sparkLifeVariation = 3.8;\n        }\n\n        // Apply quality to spark count\n        sparkFreq = sparkFreq / quality;\n\n        // Star factory for primary burst, pistils, and streamers.\n        let firstStar = true;\n        const starFactory = (angle, speedMult) => {\n            // For non-horsetail shells, compute an initial vertical speed to add to star burst.\n            // The magic number comes from testing what looks best. The ideal is that all shell\n            // bursts appear visually centered for the majority of the star life (excl. willows etc.)\n            const standardInitialSpeed = this.spreadSize / 1800;\n\n            const star = Star.add(\n                x,\n                y,\n                color || randomColor(),\n                angle,\n                speedMult * speed,\n                // add minor variation to star life\n                this.starLife + Math.random() * this.starLife * this.starLifeVariation,\n                this.horsetail ? this.comet && this.comet.speedX : 0,\n                this.horsetail ? this.comet && this.comet.speedY : -standardInitialSpeed\n            );\n\n            if (this.secondColor) {\n                star.transitionTime = this.starLife * (Math.random() * 0.05 + 0.32);\n                star.secondColor = this.secondColor;\n            }\n\n            if (this.strobe) {\n                star.transitionTime = this.starLife * (Math.random() * 0.08 + 0.46);\n                star.strobe = true;\n                // How many milliseconds between switch of strobe state \"tick\". Note that the strobe pattern\n                // is on:off:off, so this is the \"on\" duration, while the \"off\" duration is twice as long.\n                star.strobeFreq = Math.random() * 20 + 40;\n                if (this.strobeColor) {\n                    star.secondColor = this.strobeColor;\n                }\n            }\n\n            star.onDeath = onDeath;\n\n            if (this.glitter) {\n                star.sparkFreq = sparkFreq;\n                star.sparkSpeed = sparkSpeed;\n                star.sparkLife = sparkLife;\n                star.sparkLifeVariation = sparkLifeVariation;\n                star.sparkColor = this.glitterColor;\n                star.sparkTimer = Math.random() * star.sparkFreq;\n            }\n        };\n\n\n        if (typeof this.color === 'string') {\n            if (this.color === 'random') {\n                color = null; // falsey value creates random color in starFactory\n            } else {\n                color = this.color;\n            }\n\n            // Rings have positional randomness, but are rotated randomly\n            if (this.ring) {\n                const ringStartAngle = Math.random() * Math.PI;\n                const ringSquash = Math.pow(Math.random(), 2) * 0.85 + 0.15;;\n\n                createParticleArc(0, PI_2, this.starCount, 0, angle => {\n                    // Create a ring, squashed horizontally\n                    const initSpeedX = Math.sin(angle) * speed * ringSquash;\n                    const initSpeedY = Math.cos(angle) * speed;\n                    // Rotate ring\n                    const newSpeed = MyMath.pointDist(0, 0, initSpeedX, initSpeedY);\n                    const newAngle = MyMath.pointAngle(0, 0, initSpeedX, initSpeedY) + ringStartAngle;\n                    const star = Star.add(\n                        x,\n                        y,\n                        color,\n                        newAngle,\n                        // apply near cubic falloff to speed (places more particles towards outside)\n                        newSpeed, //speed,\n                        // add minor variation to star life\n                        this.starLife + Math.random() * this.starLife * this.starLifeVariation\n                    );\n\n                    if (this.glitter) {\n                        star.sparkFreq = sparkFreq;\n                        star.sparkSpeed = sparkSpeed;\n                        star.sparkLife = sparkLife;\n                        star.sparkLifeVariation = sparkLifeVariation;\n                        star.sparkColor = this.glitterColor;\n                        star.sparkTimer = Math.random() * star.sparkFreq;\n                    }\n                });\n            }\n            // Normal burst\n            else {\n                createBurst(this.starCount, starFactory);\n            }\n        } else if (Array.isArray(this.color)) {\n            if (Math.random() < 0.5) {\n                const start = Math.random() * Math.PI;\n                const start2 = start + Math.PI;\n                const arc = Math.PI;\n                color = this.color[0];\n                // Not creating a full arc automatically reduces star count.\n                createBurst(this.starCount, starFactory, start, arc);\n                color = this.color[1];\n                createBurst(this.starCount, starFactory, start2, arc);\n            } else {\n                color = this.color[0];\n                createBurst(this.starCount / 2, starFactory);\n                color = this.color[1];\n                createBurst(this.starCount / 2, starFactory);\n            }\n        } else {\n            throw new Error('Invalid shell color. Expected string or array of strings, but got: ' + this.color);\n        }\n\n        if (this.pistil) {\n            const innerShell = new Shell({\n                spreadSize: this.spreadSize * 0.5,\n                starLife: this.starLife * 0.6,\n                starLifeVariation: this.starLifeVariation,\n                starDensity: 1.4,\n                color: this.pistilColor,\n                glitter: 'light',\n                glitterColor: this.pistilColor === COLOR.Gold ? COLOR.Gold : COLOR.White\n            });\n            innerShell.burst(x, y);\n        }\n\n        if (this.streamers) {\n            const innerShell = new Shell({\n                spreadSize: this.spreadSize * 0.9,\n                starLife: this.starLife * 0.8,\n                starLifeVariation: this.starLifeVariation,\n                starCount: Math.floor(Math.max(6, this.spreadSize / 45)),\n                color: COLOR.White,\n                glitter: 'streamer'\n            });\n            innerShell.burst(x, y);\n        }\n\n        // Queue burst flash render\n        BurstFlash.add(x, y, this.spreadSize / 4);\n\n        // Play sound, but only for \"original\" shell, the one that was launched.\n        // We don't want multiple sounds from pistil or streamer \"sub-shells\".\n        // This can be detected by the presence of a comet.\n        if (this.comet) {\n            // Scale explosion sound based on current shell size and selected (max) shell size.\n            // Shooting selected shell size will always sound the same no matter the selected size,\n            // but when smaller shells are auto-fired, they will sound smaller. It doesn't sound great\n            // when a value too small is given though, so instead of basing it on proportions, we just\n            // look at the difference in size and map it to a range known to sound good.\n            const maxDiff = 2;\n            const sizeDifferenceFromMaxSize = Math.min(maxDiff, shellSizeSelector() - this.shellSize);\n            const soundScale = (1 - sizeDifferenceFromMaxSize / maxDiff) * 0.3 + 0.7;\n            soundManager.playSound('burst', soundScale);\n        }\n    }\n}\n\n\n\nconst BurstFlash = {\n    active: [],\n    _pool: [],\n\n    _new() {\n        return {}\n    },\n\n    add(x, y, radius) {\n        const instance = this._pool.pop() || this._new();\n\n        instance.x = x;\n        instance.y = y;\n        instance.radius = radius;\n\n        this.active.push(instance);\n        return instance;\n    },\n\n    returnInstance(instance) {\n        this._pool.push(instance);\n    }\n};\n\n\n\n// Helper to generate objects for storing active particles.\n// Particles are stored in arrays keyed by color (code, not name) for improved rendering performance.\nfunction createParticleCollection() {\n    const collection = {};\n    COLOR_CODES_W_INVIS.forEach(color => {\n        collection[color] = [];\n    });\n    return collection;\n}\n\n\n// Star properties (WIP)\n// -----------------------\n// transitionTime - how close to end of life that star transition happens\n\nconst Star = {\n    // Visual properties\n    drawWidth: 3,\n    airDrag: 0.98,\n    airDragHeavy: 0.992,\n\n    // Star particles will be keyed by color\n    active: createParticleCollection(),\n    _pool: [],\n\n    _new() {\n        return {};\n    },\n\n    add(x, y, color, angle, speed, life, speedOffX, speedOffY) {\n        const instance = this._pool.pop() || this._new();\n\n        instance.visible = true;\n        instance.heavy = false;\n        instance.x = x;\n        instance.y = y;\n        instance.prevX = x;\n        instance.prevY = y;\n        instance.color = color;\n        instance.speedX = Math.sin(angle) * speed + (speedOffX || 0);\n        instance.speedY = Math.cos(angle) * speed + (speedOffY || 0);\n        instance.life = life;\n        instance.fullLife = life;\n        instance.spinAngle = Math.random() * PI_2;\n        instance.spinSpeed = 0.8;\n        instance.spinRadius = 0;\n        instance.sparkFreq = 0; // ms between spark emissions\n        instance.sparkSpeed = 1;\n        instance.sparkTimer = 0;\n        instance.sparkColor = color;\n        instance.sparkLife = 750;\n        instance.sparkLifeVariation = 0.25;\n        instance.strobe = false;\n\n        this.active[color].push(instance);\n        return instance;\n    },\n\n    // Public method for cleaning up and returning an instance back to the pool.\n    returnInstance(instance) {\n        // Call onDeath handler if available (and pass it current star instance)\n        instance.onDeath && instance.onDeath(instance);\n        // Clean up\n        instance.onDeath = null;\n        instance.secondColor = null;\n        instance.transitionTime = 0;\n        instance.colorChanged = false;\n        // Add back to the pool.\n        this._pool.push(instance);\n    }\n};\n\n\nconst Spark = {\n    // Visual properties\n    drawWidth: 0, // set in `configDidUpdate()`\n    airDrag: 0.9,\n\n    // Star particles will be keyed by color\n    active: createParticleCollection(),\n    _pool: [],\n\n    _new() {\n        return {};\n    },\n\n    add(x, y, color, angle, speed, life) {\n        const instance = this._pool.pop() || this._new();\n\n        instance.x = x;\n        instance.y = y;\n        instance.prevX = x;\n        instance.prevY = y;\n        instance.color = color;\n        instance.speedX = Math.sin(angle) * speed;\n        instance.speedY = Math.cos(angle) * speed;\n        instance.life = life;\n\n        this.active[color].push(instance);\n        return instance;\n    },\n\n    // Public method for cleaning up and returning an instance back to the pool.\n    returnInstance(instance) {\n        // Add back to the pool.\n        this._pool.push(instance);\n    }\n};\n\n\n\nconst soundManager = {\n    baseURL: 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/329180/',\n    ctx: new(window.AudioContext || window.webkitAudioContext),\n    sources: {\n        lift: {\n            volume: 1,\n            playbackRateMin: 0.85,\n            playbackRateMax: 0.95,\n            fileNames: [\n\n                'lift1.mp3',\n                'lift2.mp3',\n                'lift3.mp3'\n            ]\n        },\n        burst: {\n            volume: 1,\n            playbackRateMin: 0.8,\n            playbackRateMax: 0.9,\n            fileNames: [\n                'burst1.mp3',\n                'burst2.mp3'\n            ]\n        },\n        burstSmall: {\n            volume: 0.25,\n            playbackRateMin: 0.8,\n            playbackRateMax: 1,\n            fileNames: [\n                'burst-sm-1.mp3',\n                'burst-sm-2.mp3'\n            ]\n        },\n        crackle: {\n            volume: 0.2,\n            playbackRateMin: 1,\n            playbackRateMax: 1,\n            fileNames: ['crackle1.mp3']\n        },\n        crackleSmall: {\n            volume: 0.3,\n            playbackRateMin: 1,\n            playbackRateMax: 1,\n            fileNames: ['crackle-sm-1.mp3']\n        }\n    },\n\n    preload() {\n        const allFilePromises = [];\n\n        function checkStatus(response) {\n            if (response.status >= 200 && response.status < 300) {\n                return response;\n            }\n            const customError = new Error(response.statusText);\n            customError.response = response;\n            throw customError;\n        }\n\n        const types = Object.keys(this.sources);\n        types.forEach(type => {\n            const source = this.sources[type];\n            const {\n                fileNames\n            } = source;\n            const filePromises = [];\n            fileNames.forEach(fileName => {\n                const fileURL = this.baseURL + fileName;\n                // Promise will resolve with decoded audio buffer.\n                const promise = fetch(fileURL)\n                    .then(checkStatus)\n                    .then(response => response.arrayBuffer())\n                    .then(data => new Promise(resolve => {\n                        this.ctx.decodeAudioData(data, resolve);\n                    }));\n\n                filePromises.push(promise);\n                allFilePromises.push(promise);\n            });\n\n            Promise.all(filePromises)\n                .then(buffers => {\n                    source.buffers = buffers;\n                });\n        });\n\n        return Promise.all(allFilePromises);\n    },\n\n    pauseAll() {\n        this.ctx.suspend();\n    },\n\n    resumeAll() {\n        // Play a sound with no volume for iOS. This 'unlocks' the audio context when the user first enables sound.\n        this.playSound('lift', 0);\n        // Chrome mobile requires interaction before starting audio context.\n        // The sound toggle button is triggered on 'touchstart', which doesn't seem to count as a full\n        // interaction to Chrome. I guess it needs a click? At any rate if the first thing the user does\n        // is enable audio, it doesn't work. Using a setTimeout allows the first interaction to be registered.\n        // Perhaps a better solution is to track whether the user has interacted, and if not but they try enabling\n        // sound, show a tooltip that they should tap again to enable sound.\n        setTimeout(() => {\n            this.ctx.resume();\n        }, 250);\n    },\n\n    // Private property used to throttle small burst sounds.\n    _lastSmallBurstTime: 0,\n\n    /**\n     * Play a sound of `type`. Will randomly pick a file associated with type, and play it at the specified volume\n     * and play speed, with a bit of random variance in play speed. This is all based on `sources` config.\n     *\n     * @param  {string} type - The type of sound to play.\n     * @param  {?number} scale=1 - Value between 0 and 1 (values outside range will be clamped). Scales less than one\n     *                             descrease volume and increase playback speed. This is because large explosions are\n     *                             louder, deeper, and reverberate longer than small explosions.\n     *                             Note that a scale of 0 will mute the sound.\n     */\n    playSound(type, scale = 1) {\n        // Ensure `scale` is within valid range.\n        scale = MyMath.clamp(scale, 0, 1);\n\n        // Disallow starting new sounds if sound is disabled, app is running in slow motion, or paused.\n        // Slow motion check has some wiggle room in case user doesn't finish dragging the speed bar\n        // *all* the way back.\n        if (!canPlaySoundSelector() || simSpeed < 0.95) {\n            return;\n        }\n\n        // Throttle small bursts, since floral/falling leaves shells have a lot of them.\n        if (type === 'burstSmall') {\n            const now = Date.now();\n            if (now - this._lastSmallBurstTime < 20) {\n                return;\n            }\n            this._lastSmallBurstTime = now;\n        }\n\n        const source = this.sources[type];\n\n        if (!source) {\n            throw new Error(`Sound of type \"${type}\" doesn't exist.`);\n        }\n\n        const initialVolume = source.volume;\n        const initialPlaybackRate = MyMath.random(\n            source.playbackRateMin,\n            source.playbackRateMax\n        );\n\n        // Volume descreases with scale.\n        const scaledVolume = initialVolume * scale;\n        // Playback rate increases with scale. For this, we map the scale of 0-1 to a scale of 2-1.\n        // So at a scale of 1, sound plays normally, but as scale approaches 0 speed approaches double.\n        const scaledPlaybackRate = initialPlaybackRate * (2 - scale);\n\n        const gainNode = this.ctx.createGain();\n        gainNode.gain.value = scaledVolume;\n\n        const buffer = MyMath.randomChoice(source.buffers);\n        const bufferSource = this.ctx.createBufferSource();\n        bufferSource.playbackRate.value = scaledPlaybackRate;\n        bufferSource.buffer = buffer;\n        bufferSource.connect(gainNode);\n        gainNode.connect(this.ctx.destination);\n        bufferSource.start(0);\n    }\n};\n\n\n\n\n// Kick things off.\n\nfunction setLoadingStatus(status) {\n    document.querySelector('.loading-init__status').textContent = status;\n}\n\n// CodePen profile header doesn't need audio, just initialize.\nif (IS_HEADER) {\n    init();\n} else {\n    // Allow status to render, then preload assets and start app.\n    //setLoadingStatus('献给你爱的TA ❤');\n    setTimeout(() => {\n        soundManager.preload()\n            .then(\n                init,\n                reason => {\n                    // Codepen preview doesn't like to load the audio, so just init to fix the preview for now.\n                    init();\n                    // setLoadingStatus('Error Loading Audio');\n                    return Promise.reject(reason);\n                }\n            );\n    }, 0);\n}","count_time":{"symbolsCount":"52k","symbolsTime":"48 mins."},"toc":""}