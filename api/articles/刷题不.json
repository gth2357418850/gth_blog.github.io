{"title":"要好好学习天天向上哟","uid":"33acdddb35650af797ecddd2d38891a7","slug":"刷题不","date":"2022-10-25T12:30:21.151Z","updated":"2022-10-25T12:30:21.151Z","comments":true,"path":"api/articles/刷题不.json","keywords":null,"cover":[],"content":"<h2 id=\"鸽巢原理进行排序\"><a href=\"#鸽巢原理进行排序\" class=\"headerlink\" title=\"鸽巢原理进行排序\"></a>鸽巢原理进行排序</h2><p><a href=\"https://leetcode.cn/problems/missing-two-lcci/\">https://leetcode.cn/problems/missing-two-lcci/</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span> ; i&lt;nums.<span class=\"built_in\">size</span>() ; i++)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(nums[i] != <span class=\"number\">-1</span> &amp;&amp; nums[i] != i+<span class=\"number\">1</span>) <span class=\"built_in\">swap</span>(nums[i] , nums[nums[i]<span class=\"number\">-1</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>说明：此模板用于对有规律的数进行排序，核心思想是一个萝卜一个坑。</p>\n<p>桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，我们会发现至少会有一个抽屉里面放不少于两个苹果。这一现象就是我们所说的“抽屉原理”。 抽屉原理的一般含义为：“如果每个抽屉代表一个集合，每一个苹果就可以代表一个元素，假如有n+1个元素放到n个集合中去，其中必定有一个集合里至少有两个元素。” 抽屉原理有时也被称为鸽巢原理。<br>本质上是对哈希定址法的改变。</p>\n<h2 id=\"排序算法（归并排序）\"><a href=\"#排序算法（归并排序）\" class=\"headerlink\" title=\"排序算法（归并排序）\"></a>排序算法（归并排序）</h2><p>这里放题目</p>\n<p>对于归并排序我是这样理解的，对于一个未排序的数组，我们可以将其对半分开，分开后再将其按顺序合并，那么具体的合并流程呢？首先需要先创建一个新的数组（这个数组容量为两个子数组容量的和），然后将两个子数组按大小排入这个新数组中，因为我们是将小块合并所以保证在前面的数组是按照规则排序的，那么后面的只需要比较两个小数组的第一个值即可保证不错位。</p>\n<p><img src=\"/%E5%88%B7%E9%A2%98%E4%B8%8D%20ace90e56-539e-4928-b11a-b79da42d548a/image.png\" alt=\"image.png\"></p>\n<p><img src=\"/%E5%88%B7%E9%A2%98%E4%B8%8D%20ace90e56-539e-4928-b11a-b79da42d548a/image%201.png\" alt=\"image.png\"></p>\n<h2 id=\"Python排序进阶（工具）\"><a href=\"#Python排序进阶（工具）\" class=\"headerlink\" title=\"Python排序进阶（工具）\"></a>Python排序进阶（工具）</h2><p><a href=\"https://leetcode.cn/problems/largest-number/\">https://leetcode.cn/problems/largest-number/</a></p>\n<p>我们知道Python中排序有<code>sorted(_iterable, key, reverse)</code>,而这里我们着重来说这个“key”，这个“key”是让我们<code>sorted()</code>函数真正好用的关键。</p>\n<p>针对<code>key</code>我们可以用<code>lambda:</code>或写函数来改变，也可以通过<code>functools</code>模块中的<code>cmp_to_key</code>来对自定义的<code>cmp</code>函数进行包装，然后就能赋值给<code>sorted</code>函数的关键字参数<code>key</code>，来间接实现<code>Python2</code>中<code>cmp</code>函数用于排序的效果。</p>\n<h2 id=\"Python排序进阶-2-（工具）\"><a href=\"#Python排序进阶-2-（工具）\" class=\"headerlink\" title=\"Python排序进阶(2)（工具）\"></a>Python排序进阶(2)（工具）</h2><p><a href=\"https://leetcode.cn/problems/advantage-shuffle/\">https://leetcode.cn/problems/advantage-shuffle/</a></p>\n<p>Python中还提供了一个排序的库（sortedcontainers）。</p>\n<p>这个库提供了三个类：SortedList 、SortedDict、SortedSet。我们可以直接声明一个SortedList对象，这个对象会直接对列表中的值进行排序，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sortedcontainers</span><br><span class=\"line\"></span><br><span class=\"line\">t = sortedcontainers.SortedList([<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(t)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;SortedList([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>])</span><br></pre></td></tr></table></figure>\n\n<p><strong>常见的方法</strong>：<code>add()</code>、<code>remove()</code>、<code>discard()</code>、<code>pop()</code>、<code>bisect_left()</code>、<code>count()</code>。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>时间复杂度</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>add()</td>\n<td>近似O(logn)</td>\n<td>向SortedList()中添加元素</td>\n</tr>\n<tr>\n<td>update(iterable)</td>\n<td>近似O(k*logn)</td>\n<td>向SortedList()中添加列表</td>\n</tr>\n<tr>\n<td>clear()</td>\n<td>O(n)</td>\n<td>删除所以元素</td>\n</tr>\n<tr>\n<td>discard(value)</td>\n<td>近似O(logn)</td>\n<td>删除单个元素（元素可不存在）</td>\n</tr>\n<tr>\n<td>remove()</td>\n<td>近似O(logn)</td>\n<td>删除单个元素（元素不存在报错）</td>\n</tr>\n<tr>\n<td>pop(index&#x3D;-1)</td>\n<td>近似O(logn)</td>\n<td>同列表pop</td>\n</tr>\n<tr>\n<td>bisect_left(value)</td>\n<td>近似O(logn)</td>\n<td>找出元素位置</td>\n</tr>\n<tr>\n<td>count()</td>\n<td>近似O(logn)</td>\n<td>查找个数</td>\n</tr>\n<tr>\n<td>index()</td>\n<td>近似O(logn)</td>\n<td>同列表index</td>\n</tr>\n</tbody></table>\n<p>SortedList的排序方法是系统默认的，我们也可以设置排序方法，比如数值从大到小排序</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sortedcontainers <span class=\"keyword\">import</span> SortedList</span><br><span class=\"line\"><span class=\"keyword\">from</span> operator <span class=\"keyword\">import</span> neg</span><br><span class=\"line\"> </span><br><span class=\"line\">test_sl = SortedList([<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">7</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>], key=neg)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">print</span>(test_sl)</span><br><span class=\"line\"> </span><br><span class=\"line\">output:</span><br><span class=\"line\">SortedKeyList([<span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>], key=&lt;built-<span class=\"keyword\">in</span> function neg&gt;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sortedcontainers <span class=\"keyword\">import</span> SortedList</span><br><span class=\"line\"> </span><br><span class=\"line\">test_str = SortedList([<span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;431&quot;</span>, <span class=\"string\">&quot;34&quot;</span>], key=<span class=\"keyword\">lambda</span> item:<span class=\"built_in\">len</span>(item))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(test_str)</span><br><span class=\"line\"> </span><br><span class=\"line\">output:</span><br><span class=\"line\">SortedKeyList([<span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;34&#x27;</span>, <span class=\"string\">&#x27;431&#x27;</span>], key=&lt;function &lt;<span class=\"keyword\">lambda</span>&gt; at <span class=\"number\">0x7fb883b36820</span>&gt;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"回溯（全排列）模板\"><a href=\"#回溯（全排列）模板\" class=\"headerlink\" title=\"回溯（全排列）模板\"></a>回溯（全排列）模板</h2><p><a href=\"https://leetcode.cn/problems/permutations/\">https://leetcode.cn/problems/permutations/</a></p>\n<h3 id=\"题目分析：\"><a href=\"#题目分析：\" class=\"headerlink\" title=\"题目分析：\"></a>题目分析：</h3><p>就这道题目而言，因其不包含重复数字，故不需考虑重复问题，那么怎么样实现全排列呢？我们从小都知道，全排列要有条理的从原列表中一个个拿出，而拿出后我们应该将这个元素去掉！所以我们就可以有思路了。本质上我们应将数字从列表中一个个拿出这样我们可以用一层循环遍历。用“我”的浅薄装逼的表示即为：</p>\n<p>$f(x+1)&#x3D;f(x)+d[i]$</p>\n<p>解释：$f(x)$为我们要组成的结果，$d[i]$为列表中的元素。列表元素是一遍遍减少的！这个是重要的</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">permute</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]</span>) -&gt; <span class=\"type\">List</span>[<span class=\"type\">List</span>[<span class=\"built_in\">int</span>]]:</span><br><span class=\"line\">        res = []</span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">backtracking</span>(<span class=\"params\">nums, t</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> nums:</span><br><span class=\"line\">                res.append(t)</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(nums)):</span><br><span class=\"line\">                backtracking(nums[:i]+nums[i+<span class=\"number\">1</span>:],t+[nums[i]])</span><br><span class=\"line\">        backtracking(nums,[])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"再说回来\"><a href=\"#再说回来\" class=\"headerlink\" title=\"再说回来\"></a>再说回来</h3><p>回溯法：采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p>\n<p>找到一个可能存在的正确的答案；<br>在尝试了所有可能的分步方法后宣告该问题没有答案。</p>\n<p>回溯算法关键在于：不合适就退回上一步，然后通过约束条件, 减少时间复杂度。其和深度搜索算法是有些相似之处的。</p>\n","text":"鸽巢原理进行排序https://leetcode.cn/problems/missing-two-lcci/ 123for (int i=0 ; i&lt;nums.size() ; i++)&#123; while(nums[i] != -1 &amp;&amp; nums[i...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"算法","slug":"算法","count":3,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":2,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">鸽巢原理进行排序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%89\"><span class=\"toc-text\">排序算法（归并排序）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Python%E6%8E%92%E5%BA%8F%E8%BF%9B%E9%98%B6%EF%BC%88%E5%B7%A5%E5%85%B7%EF%BC%89\"><span class=\"toc-text\">Python排序进阶（工具）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Python%E6%8E%92%E5%BA%8F%E8%BF%9B%E9%98%B6-2-%EF%BC%88%E5%B7%A5%E5%85%B7%EF%BC%89\"><span class=\"toc-text\">Python排序进阶(2)（工具）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E6%BA%AF%EF%BC%88%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%89%E6%A8%A1%E6%9D%BF\"><span class=\"toc-text\">回溯（全排列）模板</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%EF%BC%9A\"><span class=\"toc-text\">题目分析：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%EF%BC%9A\"><span class=\"toc-text\">代码：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%8D%E8%AF%B4%E5%9B%9E%E6%9D%A5\"><span class=\"toc-text\">再说回来</span></a></li></ol></li></ol>","author":{"name":"Gaoth","slug":"gaoth","avatar":"https://s2.loli.net/2022/10/24/zZ5Msr7bhigQVcj.jpg","link":"/","description":"不以为然的存在，细品起来会得到意想不到的有趣。<br /> @<b>公众号：噜啦啦小栈</b>","socials":{"github":"https://github.com//githubforgth","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/m0_51898303","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"手写数字识别","uid":"c3bb980dd99e420748682f824a1ae74e","slug":"手写数字识别","date":"2022-10-26T07:25:25.481Z","updated":"2022-10-26T07:25:25.481Z","comments":true,"path":"api/articles/手写数字识别.json","keywords":null,"cover":[],"text":"餐前祷告怎么才能让你的电脑有那么一丢丢的小智能呢，现在好像有好多方法，但是那些高大上的方法，好像我们现在难以自己去实现，不过嘛万丈高楼平地起，我们可以用我们的聪明才智来实现一些小小的智能。 基础理论 那么我们就从手写数字识别开始吧！ 我们都知道人工智能三要素是什么呢？数据、算法、...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"算法","slug":"算法","count":3,"path":"api/categories/算法.json"}],"tags":[{"name":"人工智能","slug":"人工智能","count":1,"path":"api/tags/人工智能.json"}],"author":{"name":"Gaoth","slug":"gaoth","avatar":"https://s2.loli.net/2022/10/24/zZ5Msr7bhigQVcj.jpg","link":"/","description":"不以为然的存在，细品起来会得到意想不到的有趣。<br /> @<b>公众号：噜啦啦小栈</b>","socials":{"github":"https://github.com//githubforgth","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/m0_51898303","juejin":"","customs":{}}},"feature":true},"next_post":{}}